<!DOCTYPE html>
<html>
<head>
    <script src="https://og6593g2z.qnssl.com/fundebug.0.3.3.min.js" apikey="e4ebd1d8446798b665fed4258ebd75f1ee7489bda0832a94b9d5f2a6d07d2f4b"></script>
    <meta charset="utf-8">
    
    <title>
        
        安·记</title>
    <script>
        if (location.host.indexOf('cssha.com') >= 0) {
            location.href = location.href.replace('cssha.com', 'annn.me');
        }
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta property="wb:webmaster" content="35db845a3f9d1692"/>
    <meta name="baidu-site-verification" content="VdeWu2EHCz"/>
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="cache-control" content="no-cache, must-revalidate">
    <meta name="description" content="阿安的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="安·记">
<meta property="og:url" content="http://annn.me/index.html">
<meta property="og:site_name" content="安·记">
<meta property="og:description" content="阿安的Blog">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安·记">
<meta name="twitter:description" content="阿安的Blog">
    
    <link rel="alternative" href="/atom.xml" title="安·记" type="application/rss+xm">
    
    
    <link rel="icon" href="/favicon.ico">
    
    <link href="/css/fonts/source-code-pro.woff2" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/style.css">
    
<!--百度统计-->
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?3e1fabf44865ddfe8b31fa9d84cbe4c9";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <!--<div id="header-title" class="inner">-->
      <!--<h1 id="logo-wrap">-->
        <!--<a href="/" id="logo">安·记</a>-->
      <!--</h1>-->
      <!---->
    <!--</div>-->
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        <h1 class="main-nav-link"><a href="/">安·记</a></h1>
        
          
          <a class="main-nav-link" href="/archives" target="">归档</a>
        
          
          <a class="main-nav-link" href="/categories" target="">分类</a>
        
          
          <a class="main-nav-link" href="/tags" target="">标签</a>
        
          
          <a class="main-nav-link" href="/links" target="">链接</a>
        
          
          <a class="main-nav-link" href="https://500px.com/annnhan" target="_blank">摄影</a>
        
          
          <a class="main-nav-link" href="/about" target="">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://annn.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">

  <!--首页-->
  
    
    <article id="post-implement-a-programming-language-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/implement-a-programming-language-5/" class="article-date">
  <time datetime="2018-03-23T16:00:00.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/implement-a-programming-language-5/">如何使用 JavaScript 实现一门编程语言(5) —— AST</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。<br>之前我们讲过，parser将构建一个忠实地表示程序语义的数据结构。这里的AST节点则是一个普通的JavaScript对象，它具有一个type属性，用于指定它是什么类型的节点，还有一些附加信息，附加信息的值可能因 type 而异。<br>下面是我们语言所有 AST 节点列表：</p>
<pre><code>[
    /**
     * 数字(num)
     * 比如: 123.5
     */
    { type: &quot;num&quot;, value: 123.5 },

    /**
     * 字符串(str)
     * 比如: &quot;Hello World!&quot;
     */
    { type: &quot;str&quot;, value: &quot;Hello World!&quot; },

    /**
     * 布尔值(bool)
     * 比如: true、false
     */
    { type: &quot;bool&quot;, value: true },
    { type: &quot;bool&quot;, value: false },

    /**
     * 标识符(var)
     * 比如: x
     */
    { type: &quot;var&quot;, value: &quot;x&quot; },

    /**
     * 函数表达式(lambda or λ)
     * 比如: lambda (x) 10 或者 λ (x) 10
     */
    {
        type: &quot;lambda&quot;,
        vars: [&quot;x&quot;],
        body: { type: &quot;num&quot;, value: 10 }
    },

    /**
     * 函数调用(call)
     * 比如：foo(a, 1)
     */
    {
        type: &quot;call&quot;,
        func: { type: &quot;var&quot;, value: &quot;foo&quot; },
        args: [
            { type: &quot;var&quot;, value: &quot;a&quot; },
            { type: &quot;num&quot;, &quot;value&quot;: 1 }
        ]
    },

    /**
     * 条件语句（if）
     * 比如：if foo then bar else baz
     */
    {
        type: &quot;if&quot;,
        cond: { type: &quot;var&quot;, value: &quot;foo&quot; },
        then: { type: &quot;var&quot;, value: &quot;bar&quot; },
        else: { type: &quot;var&quot;, value: &quot;baz&quot; }
    },
    // 注：else分支是可选的
    // 比如：if foo then bar
    {
        type: &quot;if&quot;,
        cond: { type: &quot;var&quot;, value: &quot;foo&quot; },
        then: { type: &quot;var&quot;, value: &quot;bar&quot; }
    },

    /**
     *  赋值表达式（assign）
     *  比如：a = 10
     */
    {
        type: &quot;assign&quot;,
        operator: &quot;=&quot;,
        left: { type: &quot;var&quot;, value: &quot;a&quot; },
        right: { type: &quot;num&quot;, value: 10 }
    },

    /**
     * 二元表达式（binary）
     * 比如：x + y * z
     */
    {
        type: &quot;binary&quot;,
        operator: &quot;+&quot;,
        left: { type: &quot;var&quot;, value: &quot;x&quot; },
        right: {
            type: &quot;binary&quot;,
            operator: &quot;*&quot;,
            left: { type: &quot;var&quot;, value: &quot;y&quot; },
            right: { type: &quot;var&quot;, value: &quot;z&quot; }
        }
    },

    /**
     * 表达式序列（prog）
     * 比如：
     * {
          a = 5;
          b = a * 2;
          a + b;
        }
     */
    {
        type: &quot;prog&quot;,
        prog: [{
            type: &quot;assign&quot;,
            operator: &quot;=&quot;,
            left: { type: &quot;var&quot;, value: &quot;a&quot; },
            right: { type: &quot;num&quot;, value: 5 }
        },
        {
            type: &quot;assign&quot;,
            operator: &quot;=&quot;,
            left: { type: &quot;var&quot;, value: &quot;b&quot; },
            right: {
                type: &quot;binary&quot;,
                operator: &quot;*&quot;,
                left: { type: &quot;var&quot;, value: &quot;a&quot; },
                right: { type: &quot;num&quot;, value: 2 }
            }
        },
        {
            type: &quot;binary&quot;,
            operator: &quot;+&quot;,
            left: { type: &quot;var&quot;, value: &quot;a&quot; },
            right: { type: &quot;var&quot;, value: &quot;b&quot; }
        }]
    }
]
</code></pre><p><em>相关文章</em></p>
<ul>
<li><a href="/implement-a-programming-language">如何使用 JavaScript 实现一门编程语言(1)——前言</a></li>
<li><a href="/implement-a-programming-language-2">如何使用 JavaScript 实现一门编程语言(2)——编写一个解析器</a></li>
<li><a href="/implement-a-programming-language-3">如何使用 JavaScript 实现一门编程语言(3)——Input stream</a></li>
<li><a href="/implement-a-programming-language-4">如何使用 JavaScript 实现一门编程语言(4)——Token stream</a></li>
<li><a href="/implement-a-programming-language-5">如何使用 JavaScript 实现一门编程语言(5)——AST</a></li>
</ul>
<p><em>原文链接：<a href="http://lisperator.net/pltut/dream" target="_blank" rel="noopener">http://lisperator.net/pltut/dream</a></em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/implement-a-programming-language-5/" data-id="cjf2c47h200415bf5v8mlwtcp" data-title="如何使用 JavaScript 实现一门编程语言(5) —— AST" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/AST/">AST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/compile/">compile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/language/">language</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/parse/">parse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/programming/">programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/编译原理/">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-implement-a-programming-language-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/implement-a-programming-language-4/" class="article-date">
  <time datetime="2018-03-23T16:00:00.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/implement-a-programming-language-4/">如何使用 JavaScript 实现一门编程语言(4) —— Token stream</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>tokenizer(标记器, 也称为“词法分析器”), 对 <a href="/implement-a-programming-language-3">字符输入流</a> 进行操作，并返回具有相同接口的流对象，但由 peek()/next() 返回的值一个个token。token是具有两个属性的对象：type和value。以下是我们所支持的token的一些示例：</p>
<pre><code>{  type：“ punc ”，value：“ （”  }            // 标点符号：parens，逗号，分号等等
{  type：“ num ”，value：5  }               // numbers
{  type：“ str ”，value：“ Hello World ！“  }  // 字符串
{  type：” kw “，value：”lambda “  }         // keywords
{  type： ” var “， value： ” a “  }             // 标识符
{  type： ” op “， value： ” ！= “  }             // 运算符
</code></pre><p>空白符和注释将被跳过，没有令牌返回。</p>
<p>为了编写tokenizer，我们需要更仔细地认识我们的语言的语法。有个办法是，根据当前字符（由input.peek()返回的）来决定读取哪种类型的token：</p>
<ol>
<li>首先，跳过空格。</li>
<li>如果然后返回。input.eof()null</li>
<li>如果它是一个井号（#），则跳过注释（在行结束后重试）。</li>
<li>如果它是一个引号，那么阅读一个字符串。</li>
<li>如果它是一个数字，那么我们继续阅读一个数字。</li>
<li>如果它是“字母”，则读取标识符或关键字token。</li>
<li>如果它是标点符号之一，则返回标点符号token。</li>
<li>如果它是运算符，则返回运算符token。</li>
<li>如果以上都不是，那就抛出错误了。input.croak()</li>
</ol>
<p>“read_next”函数作为tokenizer的核心部分 ，它实现了上面的内容：</p>
<pre><code>function read_next() {
    read_while(is_whitespace);
    if (input.eof()) return null;
    var ch = input.peek();
    if (ch == &quot;#&quot;) {
        skip_comment();
        return read_next();
    }
    if (ch == &apos;&quot;&apos;) return read_string();
    if (is_digit(ch)) return read_number();
    if (is_id_start(ch)) return read_ident();
    if (is_punc(ch)) return {
        type  : &quot;punc&quot;,
        value : input.next()
    };
    if (is_op_char(ch)) return {
        type  : &quot;op&quot;,
        value : read_while(is_op_char)
    };
    input.croak(&quot;Can&apos;t handle character: &quot; + ch);
}
</code></pre><p>这是一个充当了调度员觉得的函数，它将next()调用以获取下一个token。请注意，它使用许多专注于特定token类型的函数，例如read_string()，read_number()等等。使用这些函数的代码而导致调度程序复杂化是没有意义的，即使我们从不在别处调用它们。</p>
<p>另外需要注意的是，我们并没有在一个步骤中消耗所有的输入流。解析器每次调用下一个token时，我们都会读取一个token。如果出现分析错误，我们甚至不会到达流的末尾。</p>
<p>字符只要它们被允许作为标识符（is_id）的一部分，read_ident()就会读取他们。标识符必须以字母、λ或_开头，并且可以包含更多这样的字符或数字，或者以下之一：？！ - &lt;&gt; =。因此，foo-bar不会被看作是三个token，而是作为一个单一的标识符（一个token）。这条规则的原因是我希望能够定义名为is-pair或者string&gt;=的函数（对不起，这就是我的Lisper）。</p>
<p>此外，read_ident()函数将检查已知关键字列表中的标识符，如果它存在，它将返回一个”kw”令牌.</p>
<p>这里是我们语言的完整tokenizer：</p>
<pre><code>function TokenStream(input) {
    var current = null;
    var keywords = &quot; if then else lambda λ true false &quot;;
    return {
        next  : next,
        peek  : peek,
        eof   : eof,
        croak : input.croak
    };
    function is_keyword(x) {
        return keywords.indexOf(&quot; &quot; + x + &quot; &quot;) &gt;= 0;
    }
    function is_digit(ch) {
        return /[0-9]/i.test(ch);
    }
    function is_id_start(ch) {
        return /[a-zλ_]/i.test(ch);
    }
    function is_id(ch) {
        return is_id_start(ch) || &quot;?!-&lt;&gt;=0123456789&quot;.indexOf(ch) &gt;= 0;
    }
    function is_op_char(ch) {
        return &quot;+-*/%=&amp;|&lt;&gt;!&quot;.indexOf(ch) &gt;= 0;
    }
    function is_punc(ch) {
        return &quot;,;(){}[]&quot;.indexOf(ch) &gt;= 0;
    }
    function is_whitespace(ch) {
        return &quot; \t\n&quot;.indexOf(ch) &gt;= 0;
    }
    function read_while(predicate) {
        var str = &quot;&quot;;
        while (!input.eof() &amp;&amp; predicate(input.peek()))
            str += input.next();
        return str;
    }
    function read_number() {
        var has_dot = false;
        var number = read_while(function(ch){
            if (ch == &quot;.&quot;) {
                if (has_dot) return false;
                has_dot = true;
                return true;
            }
            return is_digit(ch);
        });
        return { type: &quot;num&quot;, value: parseFloat(number) };
    }
    function read_ident() {
        var id = read_while(is_id);
        return {
            type  : is_keyword(id) ? &quot;kw&quot; : &quot;var&quot;,
            value : id
        };
    }
    function read_escaped(end) {
        var escaped = false, str = &quot;&quot;;
        input.next();
        while (!input.eof()) {
            var ch = input.next();
            if (escaped) {
                str += ch;
                escaped = false;
            } else if (ch == &quot;\\&quot;) {
                escaped = true;
            } else if (ch == end) {
                break;
            } else {
                str += ch;
            }
        }
        return str;
    }
    function read_string() {
        return { type: &quot;str&quot;, value: read_escaped(&apos;&quot;&apos;) };
    }
    function skip_comment() {
        read_while(function(ch){ return ch != &quot;\n&quot; });
        input.next();
    }
    function read_next() {
        read_while(is_whitespace);
        if (input.eof()) return null;
        var ch = input.peek();
        if (ch == &quot;#&quot;) {
            skip_comment();
            return read_next();
        }
        if (ch == &apos;&quot;&apos;) return read_string();
        if (is_digit(ch)) return read_number();
        if (is_id_start(ch)) return read_ident();
        if (is_punc(ch)) return {
            type  : &quot;punc&quot;,
            value : input.next()
        };
        if (is_op_char(ch)) return {
            type  : &quot;op&quot;,
            value : read_while(is_op_char)
        };
        input.croak(&quot;Can&apos;t handle character: &quot; + ch);
    }
    function peek() {
        return current || (current = read_next());
    }
    function next() {
        var tok = current;
        current = null;
        return tok || read_next();
    }
    function eof() {
        return peek() == null;
    }
}
</code></pre><ul>
<li>该next()函数并不总是调用read_next()，因为它可能在之前被peek过（在这种情况下，read_next（）已经被调用并且stream被提前）。因此我们需要一个current变量跟踪当前token。</li>
<li>我们只支持十进制数与通常的符号（没有1E5的东西，没有十六进制，没有八进制）。但是如果我们需要更多，这些更改只能在read_number（）中进行，并且很容易实现。</li>
<li>与JavaScript不同，唯一不能在字符串中引用的字符是引号字符本身和反斜杠。你需要反斜杠转义他们。而且，字符串可能包含换行符，制表符等。我们太长不会解析像\n，\t等的转义。</li>
</ul>
<p>现在，我们有足够强大的工具来方便地编写解析器（parser）了，但我建议您首先看下 <a href="/implement-a-programming-language-5">AST</a> 的描述。</p>
<p><em>相关文章</em></p>
<ul>
<li><a href="/implement-a-programming-language">如何使用 JavaScript 实现一门编程语言(1)——前言</a></li>
<li><a href="/implement-a-programming-language-2">如何使用 JavaScript 实现一门编程语言(2)——编写一个解析器</a></li>
<li><a href="/implement-a-programming-language-3">如何使用 JavaScript 实现一门编程语言(3)——Input stream</a></li>
<li><a href="/implement-a-programming-language-4">如何使用 JavaScript 实现一门编程语言(4)——Token stream</a></li>
<li><a href="/implement-a-programming-language-5">如何使用 JavaScript 实现一门编程语言(5)——AST</a></li>
</ul>
<p><em>原文链接：<a href="http://lisperator.net/pltut/dream" target="_blank" rel="noopener">http://lisperator.net/pltut/dream</a></em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/implement-a-programming-language-4/" data-id="cjf2c47h1003y5bf52lfx2blo" data-title="如何使用 JavaScript 实现一门编程语言(4) —— Token stream" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/AST/">AST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/compile/">compile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/language/">language</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/parse/">parse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/programming/">programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/编译原理/">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-implement-a-programming-language-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/implement-a-programming-language-3/" class="article-date">
  <time datetime="2018-03-21T16:00:00.000Z" itemprop="datePublished">2018-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/implement-a-programming-language-3/">如何使用 JavaScript 实现一门编程语言(3) —— Input stream</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是最简单的部分。我们将创建一个“流对象”，它提供了从字符串中读取字符的操作。其中4个方法：</p>
<ul>
<li>peek() - 返回下一个值，但不从流中移除它。</li>
<li>next() - 返回下一个值，并将其从流中丢弃。</li>
<li>eof() - 当且仅当流中没有更多值时才返回true。</li>
<li>croak(msg) - throw new Error(msg)</li>
</ul>
<p>之所以包括最后一个，是因为流可以很容易地跟踪当前位置（即行/列），这对于显示错误消息很重要。</p>
<p>您可以根据您的需求随意添加更多的方法在流对象中，但对于我的教程这些就足够了。</p>
<p>因为流对象主要用来处理字符，所以 next()/ peek() 方法返回的值也是字符（JS没有char类型，它们是包含一个单一字符的字符串）。</p>
<p>这里是这个对象的完整代码，我将称之为“InputStream”。它足够简单，理解起来很容易：</p>
<pre><code>function InputStream(input) {
    var pos = 0, line = 1, col = 0;
    return {
        next  : next,
        peek  : peek,
        eof   : eof,
        croak : croak,
    };
    function next() {
        var ch = input.charAt(pos++);
        if (ch == &quot;\n&quot;) line++, col = 0; else col++;
        return ch;
    }
    function peek() {
        return input.charAt(pos);
    }
    function eof() {
        return peek() == &quot;&quot;;
    }
    function croak(msg) {
        throw new Error(msg + &quot; (&quot; + line + &quot;:&quot; + col + &quot;)&quot;);
    }
}
</code></pre><p>请注意，它不是标准的通过类创建的对象（通过 new 关键字调用）。您只需要通过 <code>var stream = InputStream(string)</code> 即可得到流对象。</p>
<p>接下来，我们将在这个对象之上编写另一个抽象： <a href="/implement-a-programming-language-3">tokenizer</a> 。</p>
<p><em>相关文章</em></p>
<ul>
<li><a href="/implement-a-programming-language">如何使用 JavaScript 实现一门编程语言(1)——前言</a></li>
<li><a href="/implement-a-programming-language-2">如何使用 JavaScript 实现一门编程语言(2)——编写一个解析器</a></li>
<li><a href="/implement-a-programming-language-3">如何使用 JavaScript 实现一门编程语言(3)——Input stream</a></li>
<li><a href="/implement-a-programming-language-4">如何使用 JavaScript 实现一门编程语言(4)——Token stream</a></li>
<li><a href="/implement-a-programming-language-5">如何使用 JavaScript 实现一门编程语言(5)——AST</a></li>
</ul>
<p><em>原文链接：<a href="http://lisperator.net/pltut/dream" target="_blank" rel="noopener">http://lisperator.net/pltut/dream</a></em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/implement-a-programming-language-3/" data-id="cjf2c47gz003w5bf5hved1pev" data-title="如何使用 JavaScript 实现一门编程语言(3) —— Input stream" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/AST/">AST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/compile/">compile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/language/">language</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/parse/">parse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/programming/">programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/编译原理/">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-implement-a-programming-language-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/implement-a-programming-language-2/" class="article-date">
  <time datetime="2018-03-20T16:00:00.000Z" itemprop="datePublished">2018-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/implement-a-programming-language-2/">如何使用 JavaScript 实现一门编程语言(2) —— 编写一个解析器</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>编写语言解析器是一项适度复杂的任务。实质上，它必须将一段代码（我们所看到的一堆字符）转换为“抽象语法树”（AST）。<br>AST是程序在内存中一种结构化的表达方式，它是“抽象”的，因为它不关心源代码是由哪些字符组成的，而是忠实地表示它的语义。我写了一个单独的页面来描述我们的AST。</p>
<p>例如，对于以下程序文本：</p>
<pre><code>sum = lambda(a, b) {
  a + b;
};
print(sum(1, 2));
</code></pre><p>我们的解析器将生成以下AST，其实也就是一个JavaScript对象：</p>
<pre><code>{
  type: &quot;prog&quot;,
  prog: [
    // first line:
    {
      type: &quot;assign&quot;,
      operator: &quot;=&quot;,
      left: { type: &quot;var&quot;, value: &quot;sum&quot; },
      right: {
        type: &quot;lambda&quot;,
        vars: [ &quot;a&quot;, &quot;b&quot; ],
        body: {
          // the body should be a &quot;prog&quot;, but because
          // it contains a single expression, our parser
          // reduces it to the expression itself.
          type: &quot;binary&quot;,
          operator: &quot;+&quot;,
          left: { type: &quot;var&quot;, value: &quot;a&quot; },
          right: { type: &quot;var&quot;, value: &quot;b&quot; }
        }
      }
    },
    // second line:
    {
      type: &quot;call&quot;,
      func: { type: &quot;var&quot;, value: &quot;print&quot; },
      args: [{
        type: &quot;call&quot;,
        func: { type: &quot;var&quot;, value: &quot;sum&quot; },
        args: [ { type: &quot;num&quot;, value: 1 },
                { type: &quot;num&quot;, value: 2 } ]
      }]
    }
  ]
}
</code></pre><p>编写解析器的主要困难在于不能正确地组织代码。解析器是一种更高级的处理字符串的方式。关于如何保持解析器复杂度的可管理性的，我有几点建议：</p>
<ul>
<li>编写多个功能模块并将它们保持较少的逻辑。在每一项功能模块中中，做好一件事！</li>
<li>不要尝试使用正则表达式进行解析。他们并不能派上用场，虽然正则对词法分析器有所帮助，但我建议将它们限制在做非常简单的事情上。</li>
<li>不要试图猜测代码的意图。如果不确定如何解析某些内容，请抛出错误消息，并确保该消息包含错误的位置（行/列）。</li>
</ul>
<p>为了简单起见，我将代码分为三部分，它们又分为许多小函数：<a href="/implement-a-programming-language-3">Input stream</a>、<a href="/implement-a-programming-language-4">Token stream</a>、<a href="/implement-a-programming-language-5">AST</a></p>
<p><em>相关文章</em></p>
<ul>
<li><a href="/implement-a-programming-language">如何使用 JavaScript 实现一门编程语言(1)——前言</a></li>
<li><a href="/implement-a-programming-language-2">如何使用 JavaScript 实现一门编程语言(2)——编写一个解析器</a></li>
<li><a href="/implement-a-programming-language-3">如何使用 JavaScript 实现一门编程语言(3)——Input stream</a></li>
<li><a href="/implement-a-programming-language-4">如何使用 JavaScript 实现一门编程语言(4)——Token stream</a></li>
<li><a href="/implement-a-programming-language-5">如何使用 JavaScript 实现一门编程语言(5)——AST</a></li>
</ul>
<p><em>原文链接：<a href="http://lisperator.net/pltut/dream" target="_blank" rel="noopener">http://lisperator.net/pltut/dream</a></em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/implement-a-programming-language-2/" data-id="cjf2c47gj003t5bf5xt5qwahk" data-title="如何使用 JavaScript 实现一门编程语言(2) —— 编写一个解析器" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/AST/">AST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/compile/">compile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/language/">language</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/parse/">parse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/programming/">programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/编译原理/">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-implement-a-programming-language" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/implement-a-programming-language/" class="article-date">
  <time datetime="2018-03-15T16:00:00.000Z" itemprop="datePublished">2018-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/implement-a-programming-language/">如何使用 JavaScript 实现一门编程语言(1) —— 前言</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是一系列关于 <a href="/tag/编译原理">如何实现编程语言</a> 的教程。如果你曾经写过一个解释器或编译器，那么这里可能没有什么新东西。但是，如果您使用正则表达式来“解析” 任何看起来像编程语言的东西，那么请至少阅读解析部分。让我们写出更少的错误代码！</p>
<p>目标受众是普通的 JavaScript / NodeJS 程序员。</p>
<p>我们要学什么？</p>
<ul>
<li>什么是解析器，以及如何编写解析器。</li>
<li>如何编写解释器。</li>
<li>为什么它们很重要。</li>
<li>编写一个编译器。</li>
<li>如何将代码转换为延续传递样式。</li>
<li>一些基本的优化技术。</li>
<li>我们的语言使用普通的 J avaScript 带来了新的例子。</li>
</ul>
<p>在两者之间，我会争论为什么 Lisp 是一种优秀的编程语言。 但是，我们将要使用的语言不是 Lisp。它有一个更丰富的语法（每个人都知道的经典中缀符号），除宏之外，它的功能与 Scheme相当。<br>可悲的是，宏是 Lisp 的最终堡垒，其他语言无法克服（除非它们被称为 Lisp 方言）。</p>
<h3 id="首先，让我们想想我们的要实现的编程语言应该是什么样子。"><a href="#首先，让我们想想我们的要实现的编程语言应该是什么样子。" class="headerlink" title="首先，让我们想想我们的要实现的编程语言应该是什么样子。"></a>首先，让我们想想我们的要实现的编程语言应该是什么样子。</h3><p>我们应该想清楚自己想要实现的目标。把语法的严格描述放在一起是一个好主意，但是我会在本教程中使语法更加简单，下面的示例就是我们要实现 “λ” 语言：</p>
<pre><code># this is a comment

println(&quot;Hello World!&quot;);

println(2 + 3 * 4);

# functions are introduced with `lambda` or `λ`
fib = lambda (n) if n &lt; 2 then n else fib(n - 1) + fib(n - 2);

println(fib(15));

print-range = λ(a, b)             # `λ` is synonym to `lambda`
                if a &lt;= b then {  # `then` here is optional as you can see below
                  print(a);
                  if a + 1 &lt;= b {
                    print(&quot;, &quot;);
                    print-range(a + 1, b);
                  } else println(&quot;&quot;);        # newline
                };
print-range(1, 5);
</code></pre><p><em>请注意，标识符名称可以包含负号字符（print-range）。这是个人品味的问题：我总是在操作符旁边放置空格，我不喜欢太多的 camelCaseNames，而且我觉得短划线比下划线更好。编写自己的语言的好处是，你可以随心所欲地做到这一点。:)</em></p>
<p>输出是：</p>
<pre><code>Hello World!
14
610
1, 2, 3, 4, 5
</code></pre>
        
          <p class="article-more-link">
            <a href="/implement-a-programming-language/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/implement-a-programming-language/" data-id="cjf2c47h300435bf5tdmwizg1" data-title="如何使用 JavaScript 实现一门编程语言(1) —— 前言" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/AST/">AST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/compile/">compile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/language/">language</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/parse/">parse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/programming/">programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/编译原理/">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-frontend-ci-cd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/frontend-ci-cd/" class="article-date">
  <time datetime="2017-05-02T16:00:00.000Z" itemprop="datePublished">2017-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/frontend-ci-cd/">前端开发如何让持续集成/持续部署(CI/CD)跑起来</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>近几年，伴随着前端技术日新月异的发展，前端开发中前后端分离，工程化，自动化等现代化的开发模式越来普及，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节。这样大提高了前端的开发效率和业务交付能力。但是，在代码集成，项目部署阶段，我们还需要引入 <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener">CI</a> / <a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">CD</a> 等现代化的软件开发实践，来减少风险，重复过程，节省我们的时间。</p>
<p>我们废话少说，这里不再对 持续集成/持续部署(CI/CD) 的概念做过多赘述，本文主要分享一下如何基于 <a href="https://about.gitlab.com/" target="_blank" rel="noopener">gitlab</a> 、 <a href="https://jenkins.io/" target="_blank" rel="noopener">jenkins</a> 让 CI/CD 跑起来。</p>
<p>其中：</p>
<ul>
<li>gitlab 用于代码版本管理，并通过其提供的 webhook 功能，触发 jenkins job 的运行。</li>
<li>jenkins 用来执行项目中 单元测试，编译打包相关 npm 命令，并发送反馈邮件，执行远程部署脚本。</li>
<li>nodejs 用于提供单元测试，编译打包功能的 npm 命令</li>
</ul>
<p>在我们的前端项目里（如： <a href="https://github.com/hanan198501/vue-spa-template" target="_blank" rel="noopener">https://github.com/hanan198501/vue-spa-template</a> ），一般使用 karma 来运行单元测试，使用 webpack 来进行打包构建， 使用 npm script 来执行这些任务，其中我们的 package.json 的 scripts 字段就有如下：</p>
<pre><code>&quot;dev&quot;: &quot;node build/dev-server.js&quot;,
&quot;build&quot;: &quot;node build/build.js&quot;, //打包构建
&quot;build-server&quot;: &quot;node build/build-server.js&quot;,
&quot;unit&quot;: &quot;karma start test/unit/karma.conf.js --single-run&quot;, // 运行单元测试
</code></pre><h3 id="如果没有-CI-CD，-我们的前端从开发到提测工作流程可能如下："><a href="#如果没有-CI-CD，-我们的前端从开发到提测工作流程可能如下：" class="headerlink" title="如果没有 CI/CD， 我们的前端从开发到提测工作流程可能如下："></a>如果没有 CI/CD， 我们的前端从开发到提测工作流程可能如下：</h3><ol>
<li>本地机器上写代码</li>
<li>在命令行输入 npm run unit，查看单元测试结果</li>
<li>提交代码，push 到 git 远程仓库</li>
<li>登录测试服务器，拉取代码，执行 npm run build，构建项目</li>
<li>如果测试服务器是基于 pm2 的 proxy server，还需要重启 server</li>
</ol>
<p>这个流程中，每一个步骤都要重复人工操作，很大增加了时间成本，不能保证操作的准确性。对于 unit 或者 build 的结果，没有一个自动的反馈机制，需要人工 check 运行结果，最后部署也是人工登录服务器执行脚本，非常繁琐。</p>
<h3 id="引入-CI-CD-以后，整个流程变成："><a href="#引入-CI-CD-以后，整个流程变成：" class="headerlink" title="引入 CI/CD 以后，整个流程变成："></a>引入 CI/CD 以后，整个流程变成：</h3><ol>
<li>本地机器上写代码</li>
<li>提交代码，push 到 git 远程仓库</li>
<li>git hook 触发 jenkins 的构建 job （自动）</li>
<li>jenkins job 中拉取项目代码，运行 npm run unit 和 npm run build，如果失败，发送邮件通知相关人。（自动）</li>
<li>jenkins job 中执行测试服务器的部署脚本 （自动）</li>
</ol>
<p>在 CI/CD 流程中，只有步骤1和步骤2需要人工操作，其他步骤都是自动运行，是一个非常标准化的流程，减少了人工操作的风险，省去了重复性工作，增强了项目的可见性。接下来我们将通过配置 jenkins 和 gitlab webhook 来实现这个流程。</p>
        
          <p class="article-more-link">
            <a href="/frontend-ci-cd/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/frontend-ci-cd/" data-id="cjf2c47fy002j5bf5ukl53oop" data-title="前端开发如何让持续集成/持续部署(CI/CD)跑起来" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/CD/">CD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/gitlab/">gitlab</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/jenkins/">jenkins</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-vue-spa-template" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/vue-spa-template/" class="article-date">
  <time datetime="2016-10-29T14:23:09.000Z" itemprop="datePublished">2016-10-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/vue-spa-template/">基于 vue 全家桶的 spa 项目模板</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>Github: <a href="https://github.com/annnhan/vue-spa-template" target="_blank">https://github.com/annnhan/vue-spa-template</a></p>
<p>最近在给团队做前端技术改造，移动端方面主要使用 vue2.0 重构，这是基于 vue-cli 脚手架生成项目模板。我们做了一些改造，<br>加入了 vue-router ，vuex 等配套设施，本地 dev server 中加入了接口 mock 功能，还增加一个 build server 来预览 build 结果页面，前后端通过 spa 的方式实现分离，并相应做了分离后的联调，部署方案。<br>通过这个项目模板，可以快速搭建起用于前后端分离后的单页应用开发环境，项目主要包含：</p>
<ul>
<li>基础库: <code>vue.js</code>、<code>vue-router</code>、<code>vuex</code>、<code>whatwg-fetch</code></li>
<li>编译/打包工具：<code>webpack</code>、<code>babel</code>、<code>node-sass</code></li>
<li>单元测试工具：<code>karma</code>、<code>mocha</code>、<code>sinon-chai</code></li>
<li>本地服务器：<code>express</code></li>
</ul>
        
          <p class="article-more-link">
            <a href="/vue-spa-template/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/vue-spa-template/" data-id="cjf2c47il007p5bf5sliruqw5" data-title="基于 vue 全家桶的 spa 项目模板" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/spa/">spa</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/vue-router/">vue-router</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/vue-js/">vue.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/vuex/">vuex</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-javascript-nginx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/javascript-nginx/" class="article-date">
  <time datetime="2015-10-01T07:33:41.000Z" itemprop="datePublished">2015-10-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/javascript-nginx/">使用 javascript 配置 nginx</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上个月的 nginx.conf 2015 大会上， 官方宣布已经支持通过 javascript 代码来配置 nginx，并把这个实现称命名为——nginscript。使用 nginscript，可以很轻易得在 niginx 配置文件中通过 js 语法来实现自定义的服务器配置。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code># 下载最新版本的 nginx 并解压
curl -O http://nginx.org/download/nginx-1.9.5.tar.gz
tar -xzvf nginx-1.9.5.tar.gz

# 下载 nginscript 模块并解压
curl -O http://hg.nginx.org/njs/archive/tip.tar.gz
tar -xzvf tip.tar.gz

# 编译并安装 nginx
$ cd nginx-1.9.5
$ ./configure --add-module=刚才解压的nginscript目录
$ make
$ make install
</code></pre>
        
          <p class="article-more-link">
            <a href="/javascript-nginx/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/javascript-nginx/" data-id="cjf2c47hg004u5bf5gcjelncv" data-title="使用 javascript 配置 nginx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-reres-googleapis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/reres-googleapis/" class="article-date">
  <time datetime="2015-09-11T05:22:51.000Z" itemprop="datePublished">2015-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/reres-googleapis/">无梯子如何正常访问使用了 googleapis 的网站</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>许多国外的网站都使用被墙掉的 googleapis.com 上的静态资源（如 font、js库 等），如果不爬墙，这些资源无法加载，导致网站无法正常访问。</p>
<p>其实，360提供了一个国内的 googleapis.com 镜像仓库（<a href="http://libs.useso.com/" target="_blank" rel="noopener">libs.useso.com</a>）。我想，当遇到 googleapis 的请求时，浏览器能自动跳转到360的镜像，就能正常访问了。</p>
<p>正好，我以前写过一个 chrome 插件 <a href="https://github.com/hanan198501/ReRes" target="_blank" rel="noopener">ReRes</a>，可以通过它来完成这项工作。</p>
<p>安装好 ReRes 后，添加一条规则：</p>
<pre><code>If URL match：^http\:\/\/(.+?)\.googleapis\.com\/(.+?)$
Response：http://$1.useso.com/$2
</code></pre><p>当浏览器中的请求匹配到 ^http\:\/\/(.+?).googleapis.com\/(.+?)$ 这个正则时，会自动跳转到 http://$1.useso.com/$2 这个 url ，其中 $1 和 $2 分别是正则中捕获到的两个分组。</p>
<p>如此，就可以正常访问使用了 googleapis 的网站。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/reres-googleapis/" data-id="cjf2c47i5006h5bf53s8ch4yq" data-title="无梯子如何正常访问使用了 googleapis 的网站" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/ReRes/">ReRes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/googleapis/">googleapis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    
    <article id="post-how-to-realize-cmd-loader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/how-to-realize-cmd-loader/" class="article-date">
  <time datetime="2015-09-03T09:03:00.000Z" itemprop="datePublished">2015-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categorie/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/how-to-realize-cmd-loader/">如何实现一个 CMD 模块加载器</a>
    </h2>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>cmd 是阿里大神玉伯提出的基于浏览器的前端模块化规范，并在 seajs 中实现了这个规范。相对于另一个在国外比较流行的前端模块化规范 amd，cmd 对于 nodejs 的使用者来说更加友好，使得类似 commonJS 模块的写法可以在浏览器中使用，同时解决了浏览器中模块异步加载的困扰。<br>关于 cmd 更详细的内容可以移步 <a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noopener">https://github.com/cmdjs/specification/blob/master/draft/module.md</a><br>今天，我们一起来学习如何实现一个浏览器端的简单的 cmd loader。</p>
<h2 id="模块加载流程"><a href="#模块加载流程" class="headerlink" title="模块加载流程"></a>模块加载流程</h2><p>下图展示了一个 cmd loader 的模块加载大体流程：</p>
<p><img src="/assets/img/cmd.png" alt="cmd loader"></p>
<ol>
<li>首先，通过 use 方法来加载入口模块，并接收一个回调函数， 当模块加载完成， 会调用回调函数，并传入对应的模块。use 方法会 check 模块有没有缓存，如果有，则从缓存中获取模块，如果没有，则创建并加载模块。</li>
<li>获取到模块后，模块可能还没有 load 完成，所以需要在模块上绑定一个 “complete” 事件，模块加载完成会触发这个事件，这时候才调用回调函数。</li>
<li>创建一个模块时，id就是模块的地址，通过创建 script 标签的方式异步加载模块的代码（factory），factory 加载完成后，会 check factory 中有没有 require 别的子模块:<ul>
<li>如果有，继续加载其子模块，并在子模块上绑定 “complete” 事件，来触发本身 的 “complete” 事件；</li>
<li>如果没有则直接触发本身的 “complete” 事件。</li>
</ul>
</li>
<li>如果子模块中还有依赖，则会递归这个过程。</li>
<li>通过事件由里到外的传递，当所有依赖的模块都 complete 的时候，最外层的入口模块才会触发 “complete” 事件，use 方法中的回调函数才会被调用。</li>
</ol>
        
          <p class="article-more-link">
            <a href="/how-to-realize-cmd-loader/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://annn.me/how-to-realize-cmd-loader/" data-id="cjf2c47g500315bf5idd4y6l2" data-title="如何实现一个 CMD 模块加载器" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/cmd/">cmd</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/loader/">loader</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 阿安<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/links" class="mobile-nav-link">链接</a>
  
    <a href="https://500px.com/annnhan" class="mobile-nav-link">摄影</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<!--<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>-->

<script src="/js/libs/jquery.2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>