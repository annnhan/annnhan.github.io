<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>安·记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://annn.me/"/>
  <updated>2018-03-16T08:44:29.000Z</updated>
  <id>http://annn.me/</id>
  
  <author>
    <name>阿安</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何使用 JavaScript 实现一门编程语言</title>
    <link href="http://annn.me/implement-a-programming-language-in-javascript/"/>
    <id>http://annn.me/implement-a-programming-language-in-javascript/</id>
    <published>2018-03-15T16:00:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一系列关于如何实现编程语言的教程。如果你曾经写过一个解释器或编译器，那么这里可能没有什么新东西。但是，如果您使用正则表达式来“解析” 任何看起来像编程语言的东西，那么请至少阅读解析部分。让我们写出更少的错误代码！</p>
<p>目标受众是普通的 JavaScript / NodeJS 程序员。</p>
<p>我们要学什么？</p>
<ul>
<li>什么是解析器，以及如何编写解析器。</li>
<li>如何编写解释器。</li>
<li>为什么它们很重要。</li>
<li>编写一个编译器。</li>
<li>如何将代码转换为延续传递样式。</li>
<li>一些基本的优化技术。</li>
<li>我们的语言使用普通的 J avaScript 带来了新的例子。</li>
</ul>
<p>在两者之间，我会争论为什么 Lisp 是一种优秀的编程语言。 但是，我们将要使用的语言不是 Lisp。它有一个更丰富的语法（每个人都知道的经典中缀符号），除宏之外，它的功能与 Scheme相当。<br>可悲的是，宏是 Lisp 的最终堡垒，其他语言无法克服（除非它们被称为 Lisp 方言）。</p>
<h3 id="但首先，让我们想想我们的要实现的编程语言应该是什么样子。"><a href="#但首先，让我们想想我们的要实现的编程语言应该是什么样子。" class="headerlink" title="但首先，让我们想想我们的要实现的编程语言应该是什么样子。"></a>但首先，让我们想想我们的要实现的编程语言应该是什么样子。</h3><p>在此之前，我们应该清楚自己想要实现的目标。把语法的严格描述放在一起是一个好主意，但是我会在本教程中使语法更加简单，所以下面是示例的λ语言：</p>
<pre><code># this is a comment

println(&quot;Hello World!&quot;);

println(2 + 3 * 4);

# functions are introduced with `lambda` or `λ`
fib = lambda (n) if n &lt; 2 then n else fib(n - 1) + fib(n - 2);

println(fib(15));

print-range = λ(a, b)             # `λ` is synonym to `lambda`
                if a &lt;= b then {  # `then` here is optional as you can see below
                  print(a);
                  if a + 1 &lt;= b {
                    print(&quot;, &quot;);
                    print-range(a + 1, b);
                  } else println(&quot;&quot;);        # newline
                };
print-range(1, 5);
</code></pre><p><em>请注意，标识符名称可以包含负号字符（print-range）。这是个人品味的问题：我总是在操作符旁边放置空格，我不喜欢很多 camelCaseNames，而且短划线比下划线更好。编写自己的语言的好处是，你可以随心所欲地做到这一点。:)</em></p>
<p>输出是：</p>
<pre><code>Hello World!
14
610
1, 2, 3, 4, 5
</code></pre><a id="more"></a>
<p>该语言看起来有点像 JavaScript，但它不同。首先，没有声明，只有表达。表达式返回一个值，可以用来代替任何其他表达式。分号需要在“序列”中分隔表达式。花括号{和}创建这样一个序列，它本身就是一个表达式。它的值是最后一个表达式返回的值。以下是一个有效的程序：</p>
<pre><code>a = {
  fib(10);  # has no side-effects, but it&apos;s computed anyway
  fib(15)   # the last semicolon can be missing
};
print(a); # prints 610
</code></pre><p>函数被引入其中一个关键字 lambda 或 λ（它们是同义词）。在关键字之后，必须有一个（可能为空的）用逗号分隔的变量名列表（可能为空），就像在 JavaScript 中一样 —— 这些是参数名称。函数体是一个单一的表达式，但它可以是一个包裹在{ … }中的序列。<br>没有 return 语句 - 在函数返回最后一个表达式给出的返回值。</p>
<p>没有 var。要引入新变量，可以使用 JSer 称之为 “立即执行函数” 的方式。就像在 JavaScript 中一样，使用 a lambda，声明变量作为参数。变量具有函数作用域范围，函数是闭包。</p>
<p>甚至 if 本身就是一种表达。在 JavaScript 中，您可以使用三元运算符获得该效果：</p>
<pre><code>a = foo() ? bar() : baz();           // JavaScript
a = if foo() then bar() else baz();  # λanguage
</code></pre><p>当分支以一个花括号开始时， then 关键字是可选，你可以在 print-range 上面看到，否则它是必需的。<br>当替代分支存在时，else 关键字是必须的。再次，then 的 else 的分支主题为一个单一的表达式，但也可以花括号 “{}” 包含多个通过 “;” 分隔的表达式。<br>当 else 分支不存在并且 if 条件结果为 false，if 表达式的结果是 false。因此，false 是一个关键词，它表示我们的语言中唯一的 falsy 值：</p>
<pre><code>if foo() then print(&quot;OK&quot;);
</code></pre><p>当 foo() 的结果不是 false 是，这点程序将会打印 “OK”。还有一个用于表示”真”的关键字 true，不是所非 false（当使用 JavaScript中 === 运算符的时候）的值都被理解成 true （其中包括数字 0 和空字符串 “”）。</p>
<p>还要注意，使用括号包裹 if 条件没有意义。不过，虽然它们是多余的，你添加它们也没有错误。</p>
<p>整个程序被解析，就好像它被嵌入大括号中一样，因此，除了最后一个表达式，您需要在每个表达式后面放置一个分号。</p>
<p>好了，这是就我们的小 λ 语言。它不一定是很完善的的。它的语法看起来很可爱，但也有陷阱。它有很多缺失的功能，如对象或数组; 我们并不关注这些缺失，因为对我们的旅程并不重要。只要你掌握了这个教程的所有内容，你可以轻松实现这些缺失的功能。</p>
<p><strong>在下一节中，我们将为这个语言编写一个解析器。</strong></p>
<p><em>原文链接：<a href="http://lisperator.net/pltut/dream" target="_blank" rel="external">http://lisperator.net/pltut/dream</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一系列关于如何实现编程语言的教程。如果你曾经写过一个解释器或编译器，那么这里可能没有什么新东西。但是，如果您使用正则表达式来“解析” 任何看起来像编程语言的东西，那么请至少阅读解析部分。让我们写出更少的错误代码！&lt;/p&gt;
&lt;p&gt;目标受众是普通的 JavaScript / NodeJS 程序员。&lt;/p&gt;
&lt;p&gt;我们要学什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是解析器，以及如何编写解析器。&lt;/li&gt;
&lt;li&gt;如何编写解释器。&lt;/li&gt;
&lt;li&gt;为什么它们很重要。&lt;/li&gt;
&lt;li&gt;编写一个编译器。&lt;/li&gt;
&lt;li&gt;如何将代码转换为延续传递样式。&lt;/li&gt;
&lt;li&gt;一些基本的优化技术。&lt;/li&gt;
&lt;li&gt;我们的语言使用普通的 J avaScript 带来了新的例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在两者之间，我会争论为什么 Lisp 是一种优秀的编程语言。 但是，我们将要使用的语言不是 Lisp。它有一个更丰富的语法（每个人都知道的经典中缀符号），除宏之外，它的功能与 Scheme相当。&lt;br&gt;可悲的是，宏是 Lisp 的最终堡垒，其他语言无法克服（除非它们被称为 Lisp 方言）。&lt;/p&gt;
&lt;h3 id=&quot;但首先，让我们想想我们的要实现的编程语言应该是什么样子。&quot;&gt;&lt;a href=&quot;#但首先，让我们想想我们的要实现的编程语言应该是什么样子。&quot; class=&quot;headerlink&quot; title=&quot;但首先，让我们想想我们的要实现的编程语言应该是什么样子。&quot;&gt;&lt;/a&gt;但首先，让我们想想我们的要实现的编程语言应该是什么样子。&lt;/h3&gt;&lt;p&gt;在此之前，我们应该清楚自己想要实现的目标。把语法的严格描述放在一起是一个好主意，但是我会在本教程中使语法更加简单，所以下面是示例的λ语言：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# this is a comment

println(&amp;quot;Hello World!&amp;quot;);

println(2 + 3 * 4);

# functions are introduced with `lambda` or `λ`
fib = lambda (n) if n &amp;lt; 2 then n else fib(n - 1) + fib(n - 2);

println(fib(15));

print-range = λ(a, b)             # `λ` is synonym to `lambda`
                if a &amp;lt;= b then {  # `then` here is optional as you can see below
                  print(a);
                  if a + 1 &amp;lt;= b {
                    print(&amp;quot;, &amp;quot;);
                    print-range(a + 1, b);
                  } else println(&amp;quot;&amp;quot;);        # newline
                };
print-range(1, 5);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;请注意，标识符名称可以包含负号字符（print-range）。这是个人品味的问题：我总是在操作符旁边放置空格，我不喜欢很多 camelCaseNames，而且短划线比下划线更好。编写自己的语言的好处是，你可以随心所欲地做到这一点。:)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;输出是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hello World!
14
610
1, 2, 3, 4, 5
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="javascript" scheme="http://annn.me/tag/javascript/"/>
    
      <category term="parse" scheme="http://annn.me/tag/parse/"/>
    
      <category term="programming" scheme="http://annn.me/tag/programming/"/>
    
      <category term="language" scheme="http://annn.me/tag/language/"/>
    
      <category term="AST" scheme="http://annn.me/tag/AST/"/>
    
      <category term="compile" scheme="http://annn.me/tag/compile/"/>
    
  </entry>
  
  <entry>
    <title>前端开发如何让持续集成/持续部署(CI/CD)跑起来</title>
    <link href="http://annn.me/frontend-ci-cd/"/>
    <id>http://annn.me/frontend-ci-cd/</id>
    <published>2017-05-02T16:00:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>近几年，伴随着前端技术日新月异的发展，前端开发中前后端分离，工程化，自动化等现代化的开发模式越来普及，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节。这样大提高了前端的开发效率和业务交付能力。但是，在代码集成，项目部署阶段，我们还需要引入 <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">CI</a> / <a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="external">CD</a> 等现代化的软件开发实践，来减少风险，重复过程，节省我们的时间。</p>
<p>我们废话少说，这里不再对 持续集成/持续部署(CI/CD) 的概念做过多赘述，本文主要分享一下如何基于 <a href="https://about.gitlab.com/" target="_blank" rel="external">gitlab</a> 、 <a href="https://jenkins.io/" target="_blank" rel="external">jenkins</a> 让 CI/CD 跑起来。</p>
<p>其中：</p>
<ul>
<li>gitlab 用于代码版本管理，并通过其提供的 webhook 功能，触发 jenkins job 的运行。</li>
<li>jenkins 用来执行项目中 单元测试，编译打包相关 npm 命令，并发送反馈邮件，执行远程部署脚本。</li>
<li>nodejs 用于提供单元测试，编译打包功能的 npm 命令</li>
</ul>
<p>在我们的前端项目里（如： <a href="https://github.com/hanan198501/vue-spa-template" target="_blank" rel="external">https://github.com/hanan198501/vue-spa-template</a> ），一般使用 karma 来运行单元测试，使用 webpack 来进行打包构建， 使用 npm script 来执行这些任务，其中我们的 package.json 的 scripts 字段就有如下：</p>
<pre><code>&quot;dev&quot;: &quot;node build/dev-server.js&quot;,
&quot;build&quot;: &quot;node build/build.js&quot;, //打包构建
&quot;build-server&quot;: &quot;node build/build-server.js&quot;,
&quot;unit&quot;: &quot;karma start test/unit/karma.conf.js --single-run&quot;, // 运行单元测试
</code></pre><h3 id="如果没有-CI-CD，-我们的前端从开发到提测工作流程可能如下："><a href="#如果没有-CI-CD，-我们的前端从开发到提测工作流程可能如下：" class="headerlink" title="如果没有 CI/CD， 我们的前端从开发到提测工作流程可能如下："></a>如果没有 CI/CD， 我们的前端从开发到提测工作流程可能如下：</h3><ol>
<li>本地机器上写代码</li>
<li>在命令行输入 npm run unit，查看单元测试结果</li>
<li>提交代码，push 到 git 远程仓库</li>
<li>登录测试服务器，拉取代码，执行 npm run build，构建项目</li>
<li>如果测试服务器是基于 pm2 的 proxy server，还需要重启 server</li>
</ol>
<p>这个流程中，每一个步骤都要重复人工操作，很大增加了时间成本，不能保证操作的准确性。对于 unit 或者 build 的结果，没有一个自动的反馈机制，需要人工 check 运行结果，最后部署也是人工登录服务器执行脚本，非常繁琐。</p>
<h3 id="引入-CI-CD-以后，整个流程变成："><a href="#引入-CI-CD-以后，整个流程变成：" class="headerlink" title="引入 CI/CD 以后，整个流程变成："></a>引入 CI/CD 以后，整个流程变成：</h3><ol>
<li>本地机器上写代码</li>
<li>提交代码，push 到 git 远程仓库</li>
<li>git hook 触发 jenkins 的构建 job （自动）</li>
<li>jenkins job 中拉取项目代码，运行 npm run unit 和 npm run build，如果失败，发送邮件通知相关人。（自动）</li>
<li>jenkins job 中执行测试服务器的部署脚本 （自动）</li>
</ol>
<p>在 CI/CD 流程中，只有步骤1和步骤2需要人工操作，其他步骤都是自动运行，是一个非常标准化的流程，减少了人工操作的风险，省去了重复性工作，增强了项目的可见性。接下来我们将通过配置 jenkins 和 gitlab webhook 来实现这个流程。</p>
<a id="more"></a>
<h3 id="配置项目的-jenkins-job"><a href="#配置项目的-jenkins-job" class="headerlink" title="配置项目的 jenkins job"></a>配置项目的 jenkins job</h3><p>首先，在 jenkins 中需要安装 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin" target="_blank" rel="external">Gitlab Hook Plugin</a> 这个插件，以支持 gitlab 的 webhook 功能。</p>
<ol>
<li><p>在 jenkins 左边栏点击 “新建”， 输入 job 名称，选择 “构建一个自由风格的软件项目” 一项。点击 “OK”<br><img src="/assets/img/ci-cd-creact-job.png" alt=""></p>
</li>
<li><p>进入 job 配置页面，点击 “General” 选项，配置名称和描述<br><img src="/assets/img/ci-cd-job-general.png" alt=""></p>
</li>
<li><p>点击 “源码管理” 选项，配置项目的 git 仓库地址的需要构建的分支信息<br><img src="/assets/img/ci-cd-job-code.png" alt=""></p>
</li>
<li><p>点击 “构建触发器” 选项，配置 job 构建时机，勾选 “Poll SCM”，”日程表” 留空。即可通过 gitlab webhook 来触发 job 构建<br><img src="/assets/img/ci-cd-job-trigger.png" alt=""></p>
</li>
<li><p>点击 “构建” 选项，再点击 “增加构建步骤”， 选择 “Execute shell”，配置构建命令。 如下，这里配置了 <code>cnpm install</code>、<code>npm run unit</code>、<code>npm run build</code>, 分别做安装依赖、单元测试、编译打包三件事。<br><img src="/assets/img/ci-cd-job-build.png" alt=""></p>
</li>
<li><p>点击 “构建后操作” 选项，添加两个构建后操作步骤：</p>
<ul>
<li>“E-mail Notification”，配置构建失败的邮件通知人；</li>
<li>“Send build artifacts over ssh”, 执行预先写好的远程服务器的部署脚本<br><img src="/assets/img/ci-cd-job-after.png" alt=""></li>
</ul>
</li>
<li><p>点击最下方的 “保存”，job 创建完毕。</p>
</li>
</ol>
<h3 id="配置-gitlab-webhook"><a href="#配置-gitlab-webhook" class="headerlink" title="配置 gitlab webhook"></a>配置 gitlab webhook</h3><p>进入项目的 gitlab 页面 &gt;&gt; Settings &gt;&gt; Integrations , 添加一条 webhook: URL 中输入”<a href="http://你的jenkins服务器host/gitlab/build_now&quot;，" target="_blank" rel="external">http://你的jenkins服务器host/gitlab/build_now&quot;，</a> Trigger 勾选Push events，点击 “Add webhook”。<br><img src="/assets/img/ci-cd-gitlab-webhook.png" alt=""></p>
<p>这样，当有代码 push 到git 仓库时，gitlab 会想 jenkins 服务器发送提交 post 请求，触发之前创建好的 jenkins job 运行, 代码从开发到部署测试，是一个持续的过程，同时对整个过程错误提供了反馈机制。</p>
<p>从此，前端开发再也不用关心代码 push 以后的事情，写代码更加专注和自信了！！**</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近几年，伴随着前端技术日新月异的发展，前端开发中前后端分离，工程化，自动化等现代化的开发模式越来普及，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节。这样大提高了前端的开发效率和业务交付能力。但是，在代码集成，项目部署阶段，我们还需要引入 &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CI&lt;/a&gt; / &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_delivery&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CD&lt;/a&gt; 等现代化的软件开发实践，来减少风险，重复过程，节省我们的时间。&lt;/p&gt;
&lt;p&gt;我们废话少说，这里不再对 持续集成/持续部署(CI/CD) 的概念做过多赘述，本文主要分享一下如何基于 &lt;a href=&quot;https://about.gitlab.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gitlab&lt;/a&gt; 、 &lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jenkins&lt;/a&gt; 让 CI/CD 跑起来。&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gitlab 用于代码版本管理，并通过其提供的 webhook 功能，触发 jenkins job 的运行。&lt;/li&gt;
&lt;li&gt;jenkins 用来执行项目中 单元测试，编译打包相关 npm 命令，并发送反馈邮件，执行远程部署脚本。&lt;/li&gt;
&lt;li&gt;nodejs 用于提供单元测试，编译打包功能的 npm 命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我们的前端项目里（如： &lt;a href=&quot;https://github.com/hanan198501/vue-spa-template&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/hanan198501/vue-spa-template&lt;/a&gt; ），一般使用 karma 来运行单元测试，使用 webpack 来进行打包构建， 使用 npm script 来执行这些任务，其中我们的 package.json 的 scripts 字段就有如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;dev&amp;quot;: &amp;quot;node build/dev-server.js&amp;quot;,
&amp;quot;build&amp;quot;: &amp;quot;node build/build.js&amp;quot;, //打包构建
&amp;quot;build-server&amp;quot;: &amp;quot;node build/build-server.js&amp;quot;,
&amp;quot;unit&amp;quot;: &amp;quot;karma start test/unit/karma.conf.js --single-run&amp;quot;, // 运行单元测试
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;如果没有-CI-CD，-我们的前端从开发到提测工作流程可能如下：&quot;&gt;&lt;a href=&quot;#如果没有-CI-CD，-我们的前端从开发到提测工作流程可能如下：&quot; class=&quot;headerlink&quot; title=&quot;如果没有 CI/CD， 我们的前端从开发到提测工作流程可能如下：&quot;&gt;&lt;/a&gt;如果没有 CI/CD， 我们的前端从开发到提测工作流程可能如下：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;本地机器上写代码&lt;/li&gt;
&lt;li&gt;在命令行输入 npm run unit，查看单元测试结果&lt;/li&gt;
&lt;li&gt;提交代码，push 到 git 远程仓库&lt;/li&gt;
&lt;li&gt;登录测试服务器，拉取代码，执行 npm run build，构建项目&lt;/li&gt;
&lt;li&gt;如果测试服务器是基于 pm2 的 proxy server，还需要重启 server&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个流程中，每一个步骤都要重复人工操作，很大增加了时间成本，不能保证操作的准确性。对于 unit 或者 build 的结果，没有一个自动的反馈机制，需要人工 check 运行结果，最后部署也是人工登录服务器执行脚本，非常繁琐。&lt;/p&gt;
&lt;h3 id=&quot;引入-CI-CD-以后，整个流程变成：&quot;&gt;&lt;a href=&quot;#引入-CI-CD-以后，整个流程变成：&quot; class=&quot;headerlink&quot; title=&quot;引入 CI/CD 以后，整个流程变成：&quot;&gt;&lt;/a&gt;引入 CI/CD 以后，整个流程变成：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;本地机器上写代码&lt;/li&gt;
&lt;li&gt;提交代码，push 到 git 远程仓库&lt;/li&gt;
&lt;li&gt;git hook 触发 jenkins 的构建 job （自动）&lt;/li&gt;
&lt;li&gt;jenkins job 中拉取项目代码，运行 npm run unit 和 npm run build，如果失败，发送邮件通知相关人。（自动）&lt;/li&gt;
&lt;li&gt;jenkins job 中执行测试服务器的部署脚本 （自动）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 CI/CD 流程中，只有步骤1和步骤2需要人工操作，其他步骤都是自动运行，是一个非常标准化的流程，减少了人工操作的风险，省去了重复性工作，增强了项目的可见性。接下来我们将通过配置 jenkins 和 gitlab webhook 来实现这个流程。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="CD" scheme="http://annn.me/tag/CD/"/>
    
      <category term="gitlab" scheme="http://annn.me/tag/gitlab/"/>
    
      <category term="jenkins" scheme="http://annn.me/tag/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>基于 vue 全家桶的 spa 项目模板</title>
    <link href="http://annn.me/vue-spa-template/"/>
    <id>http://annn.me/vue-spa-template/</id>
    <published>2016-10-29T14:23:09.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>Github: <a href="https://github.com/annnhan/vue-spa-template" target="_blank">https://github.com/annnhan/vue-spa-template</a></p>
<p>最近在给团队做前端技术改造，移动端方面主要使用 vue2.0 重构，这是基于 vue-cli 脚手架生成项目模板。我们做了一些改造，<br>加入了 vue-router ，vuex 等配套设施，本地 dev server 中加入了接口 mock 功能，还增加一个 build server 来预览 build 结果页面，前后端通过 spa 的方式实现分离，并相应做了分离后的联调，部署方案。<br>通过这个项目模板，可以快速搭建起用于前后端分离后的单页应用开发环境，项目主要包含：</p>
<ul>
<li>基础库: <code>vue.js</code>、<code>vue-router</code>、<code>vuex</code>、<code>whatwg-fetch</code></li>
<li>编译/打包工具：<code>webpack</code>、<code>babel</code>、<code>node-sass</code></li>
<li>单元测试工具：<code>karma</code>、<code>mocha</code>、<code>sinon-chai</code></li>
<li>本地服务器：<code>express</code></li>
</ul>
<a id="more"></a>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code>├── README.md                       项目介绍
├── index.html                      入口页面
├── build                           构建脚本目录
│   ├── build-server.js                 运行本地构建服务器，可以访问构建后的页面
│   ├── build.js                        生产环境构建脚本
│   ├── dev-client.js                   开发服务器热重载脚本，主要用来实现开发阶段的页面自动刷新
│   ├── dev-server.js                   运行本地开发服务器
│   ├── utils.js                        构建相关工具方法
│   ├── webpack.base.conf.js            wabpack基础配置
│   ├── webpack.dev.conf.js             wabpack开发环境配置
│   └── webpack.prod.conf.js            wabpack生产环境配置
├── config                          项目配置
│   ├── dev.env.js                      开发环境变量
│   ├── index.js                        项目配置文件
│   ├── prod.env.js                     生产环境变量
│   └── test.env.js                     测试环境变量
├── mock                            mock数据目录
│   └── hello.js
├── package.json                    npm包配置文件，里面定义了项目的npm脚本，依赖包等信息
├── src                             源码目录
│   ├── main.js                         入口js文件
│   ├── app.vue                         根组件
│   ├── components                      公共组件目录
│   │   └── title.vue
│   ├── assets                          资源目录，这里的资源会被wabpack构建
│   │   └── images
│   │       └── logo.png
│   ├── routes                          前端路由
│   │   └── index.js
│   ├── store                           应用级数据（state）
│   │   └── index.js
│   └── views                           页面目录
│       ├── hello.vue
│       └── notfound.vue
├── static                          纯静态资源，不会被wabpack构建。
└── test                            测试文件目录（unit&amp;e2e）
    └── unit                            单元测试
        ├── index.js                        入口脚本
        ├── karma.conf.js                   karma配置文件
        └── specs                           单测case目录
            └── Hello.spec.js
</code></pre><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>本项目依赖 node.js， 使用前先安装 node.js 和 cnpm（显著提升依赖包的下载速度）。</p>
<ol>
<li>自行下载并安装 node.js： <a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a></li>
<li><p>然后安装 cnpm 命令：</p>
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre></li>
</ol>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><pre><code>git clone https://github.com/hanan198501/vue-spa-template.git
cd vue-spa-template
cnpm install
npm run dev
</code></pre><h2 id="命令列表："><a href="#命令列表：" class="headerlink" title="命令列表："></a>命令列表：</h2><pre><code>#开启本地开发服务器，监控项目文件的变化，实时构建并自动刷新浏览器，浏览器访问 http://localhost:8081
npm run dev

#使用生产环境配置构建项目，构建好的文件会输出到 &quot;dist&quot; 目录，
npm run build

#运行构建服务器，可以查看构建的页面
npm run build-server

#运行单元测试
npm run unit
</code></pre><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>项目基于 spa 方式实现前后端分离，后端将所有 url 都返回到同一个 jsp 页面（由前端提供），此 jsp 页面也是前端的入口页面。然后路由由前端控制（基于vue-router），根据不同的 url 加载相应数据和组件进行渲染。</p>
<h2 id="接口-mock"><a href="#接口-mock" class="headerlink" title="接口 mock"></a>接口 mock</h2><p>前后端分离后，开发前需要和后端同学定义好接口信息（请求地址，参数，返回信息等），前端通过 mock 的方式，即可开始编码，无需等待后端接口 ready。<br>项目的本地开发服务器是基于 express 搭建的，通过 express 的中间件机制，我们已经在 dev-server 中添加了接口 mock 功能。<br>开发时，接口的 mock 数据统一放在 mock 目录下，每个文件内如下：</p>
<pre><code>module.exports = {

  // 接口地址
  api: &apos;/api/hello&apos;,

  // 返回数据 参考http://expressjs.com/zh-cn/4x/api.html
  response: function (req, res) {
    res.send(`
      &lt;p&gt;hello vue!&lt;/p&gt;
    `);
  }
}
</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>开发时可以使用 ES2015 module 语法，构建时每个文件会编译成 amd 模块。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>整个应用通过 vue 组件的方式搭建起来，通过 vue-router 控制相应组件的展现，组件树结构如下：</p>
<pre><code>app.vue                         根组件（整个应用只有一个）
    ├──view1.vue                    页面级组件，放在 views 目录里面，有子组件时，可以建立子目录
    │   ├──component1.vue               功能组件，公用的放在 components 目录，否则放在 views 子目录
    │   ├──component2.vue
    │   └──component3.vue
    ├──view2.vue
    │   ├──component1.vue
    │   └──component4.vue
    └──view3.vue
        ├──component5.vue
        ……
</code></pre><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>可以为每个组件编写单元测试，放在 <code>test/unit/specs</code> 目录下面, 单元测试用例的目录结构建议和测试的文件保持一致（相对于src），每个测试用例文件名以 <code>.spec.js</code>结尾。<br>执行 <code>npm run unit</code> 时会遍历所有的 <code>spec.js</code> 文件，产出测试报告在 <code>test/unit/coverage</code> 目录。</p>
<h2 id="联调方式"><a href="#联调方式" class="headerlink" title="联调方式"></a>联调方式</h2><p>前后端分离后，由于服务端和前端的开发环境处于2台不同的机器上，前端的异步请求需要代理到后端机器中。<br>联调的时候，只需通过 proxy 参数运行 dev 脚本即可，所有 mock 目录下定义的接口将会转发到 proxy 参数指定的机器：</p>
<pre><code># 172.16.36.90：8083 为后端机器的环境地址
npm run dev -- --proxy=172.16.36.90/:8083
</code></pre><p>这样，如果 mock 目录下有定义了接口 /api/hello ，将会转发到 <a href="http://172.16.36.90/:8083/api/hello" target="_blank" rel="external">http://172.16.36.90/:8083/api/hello</a></p>
<h2 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h2><p>分离后前后端代码会存放在2个单独的 git 仓库中，构建过程也是分开的。后端构建时，需要依赖前端的构建结果。具体流程如下：</p>
<ol>
<li>pull 前端项目代码</li>
<li>构建前端（构建结果放在dist目录）</li>
<li>pull 后端代码</li>
<li>将前端的构建结果（dist目录里的文件）复制到后端工程中</li>
<li>构建后端</li>
</ol>
<p>提测时，此过程可以借助 jenkins 配置。上线时，需要运维同学配合修改上线脚本。</p>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul>
<li>vue.js 官网：<a href="https://vuejs.org/" target="_blank" rel="external">https://vuejs.org/</a></li>
<li>vue.js 中文网： <a href="http://vuefe.cn/" target="_blank" rel="external">http://vuefe.cn/</a></li>
<li>vue-router 文档：<a href="http://router.vuejs.org/zh-cn/index.html" target="_blank" rel="external">http://router.vuejs.org/zh-cn/index.html/</a></li>
<li>vuex 文档：<a href="http://vuex.vuejs.org/" target="_blank" rel="external">http://vuex.vuejs.org/</a></li>
<li>webpack 文档：<a href="https://webpack.github.io/docs/" target="_blank" rel="external">https://webpack.github.io/docs/</a></li>
<li>ES2015 入门教程：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></li>
<li>scss 文档：<a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html" target="_blank" rel="external">http://sass-lang.com/documentation/file.SASS_REFERENCE.html</a></li>
<li>mocha 文档: <a href="http://mochajs.org/" target="_blank" rel="external">http://mochajs.org/</a></li>
<li>express 中文官网：<a href="http://expressjs.com/zh-cn/" target="_blank" rel="external">http://expressjs.com/zh-cn/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目简介&quot;&gt;&lt;a href=&quot;#项目简介&quot; class=&quot;headerlink&quot; title=&quot;项目简介&quot;&gt;&lt;/a&gt;项目简介&lt;/h2&gt;&lt;p&gt;Github: &lt;a href=&quot;https://github.com/annnhan/vue-spa-template&quot; target=&quot;_blank&quot;&gt;https://github.com/annnhan/vue-spa-template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近在给团队做前端技术改造，移动端方面主要使用 vue2.0 重构，这是基于 vue-cli 脚手架生成项目模板。我们做了一些改造，&lt;br&gt;加入了 vue-router ，vuex 等配套设施，本地 dev server 中加入了接口 mock 功能，还增加一个 build server 来预览 build 结果页面，前后端通过 spa 的方式实现分离，并相应做了分离后的联调，部署方案。&lt;br&gt;通过这个项目模板，可以快速搭建起用于前后端分离后的单页应用开发环境，项目主要包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础库: &lt;code&gt;vue.js&lt;/code&gt;、&lt;code&gt;vue-router&lt;/code&gt;、&lt;code&gt;vuex&lt;/code&gt;、&lt;code&gt;whatwg-fetch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译/打包工具：&lt;code&gt;webpack&lt;/code&gt;、&lt;code&gt;babel&lt;/code&gt;、&lt;code&gt;node-sass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;单元测试工具：&lt;code&gt;karma&lt;/code&gt;、&lt;code&gt;mocha&lt;/code&gt;、&lt;code&gt;sinon-chai&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;本地服务器：&lt;code&gt;express&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="vue.js" scheme="http://annn.me/tag/vue-js/"/>
    
      <category term="spa" scheme="http://annn.me/tag/spa/"/>
    
      <category term="vuex" scheme="http://annn.me/tag/vuex/"/>
    
      <category term="vue-router" scheme="http://annn.me/tag/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>使用 javascript 配置 nginx</title>
    <link href="http://annn.me/javascript-nginx/"/>
    <id>http://annn.me/javascript-nginx/</id>
    <published>2015-10-01T07:33:41.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上个月的 nginx.conf 2015 大会上， 官方宣布已经支持通过 javascript 代码来配置 nginx，并把这个实现称命名为——nginscript。使用 nginscript，可以很轻易得在 niginx 配置文件中通过 js 语法来实现自定义的服务器配置。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code># 下载最新版本的 nginx 并解压
curl -O http://nginx.org/download/nginx-1.9.5.tar.gz
tar -xzvf nginx-1.9.5.tar.gz

# 下载 nginscript 模块并解压
curl -O http://hg.nginx.org/njs/archive/tip.tar.gz
tar -xzvf tip.tar.gz

# 编译并安装 nginx
$ cd nginx-1.9.5
$ ./configure --add-module=刚才解压的nginscript目录
$ make
$ make install
</code></pre><a id="more"></a>
<h2 id="在-nignx-conf-中使用-nginscript"><a href="#在-nignx-conf-中使用-nginscript" class="headerlink" title="在 nignx.conf 中使用 nginscript"></a>在 nignx.conf 中使用 nginscript</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>使用 js_set 指令可以通过 javascript 代码来定义一个变量：</p>
<pre><code>js_set $msg &quot;
   var m = &apos;Hello &apos;;
   m += &apos;world!&apos;;
   m;
&quot;;
</code></pre><p>这些变量可以被其他的 nginx 指令使用：</p>
<pre><code>location /hello {
    add_header Content-Type text/plain;
    return 200 $msg;
}
</code></pre><h3 id="执行-javascript-代码片段"><a href="#执行-javascript-代码片段" class="headerlink" title="执行 javascript 代码片段"></a>执行 javascript 代码片段</h3><p>使用 js_run 指令可以执行指定的 javacript 代码：</p>
<pre><code>location /hello {
    js_run &quot;
        var res;
        res = $r.response;

        res.contentType = &apos;text/plain&apos;;
        res.status = 200;
        res.sendHeader();

        res.send( &apos;Hello, world!&apos; );
        res.finish();
    &quot;;
}
</code></pre><h3 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h3><p>在 javascript 代码中可以通过 $r 变量来获取到请求对象，请求方相关信息都会保存在这个变量上：</p>
<pre><code>js_set $summary &quot;
    var a, s, h;

    s = &apos;Request summary\n\n&apos;;

    s += &apos;Method: &apos; + $r.method + &apos;\n&apos;;
    s += &apos;HTTP version: &apos; + $r.httpVersion + &apos;\n&apos;;
    s += &apos;Host: &apos; + $r.headers.host + &apos;\n&apos;;
    s += &apos;Remote Address: &apos; + $r.remoteAddress + &apos;\n&apos;;
    s += &apos;URI: &apos; + $r.uri + &apos;\n&apos;;

    s += &apos;Headers:\n&apos;;
    for (h in $r.headers) {
        s += &apos;  header \&quot;&apos; + h + &apos;\&quot; is \&quot;&apos; + $r.headers[h] + &apos;\&quot;\n&apos;;
    }

    s += &apos;Args:\n&apos;;
    for (a in $r.args) {
        s += &apos;  arg \&quot;&apos; + a + &apos;\&quot; is \&quot;&apos; + $r.args[a] + &apos;\&quot;\n&apos;;
    }

    s;
&quot;;
</code></pre><h3 id="response-响应对象"><a href="#response-响应对象" class="headerlink" title="response 响应对象"></a>response 响应对象</h3><p>在 javascript 代码中可以通过 $r.response 来获取到响应对象，用于设置响应内容：</p>
<pre><code>js_run &quot;
    var res = $r.response;

    res.contentType = &apos;text/plain&apos;;
    res.status = 200;
    res.sendHeader();

    res.send( &apos;Hello, world!&apos; );
    res.finish();
&quot;;
</code></pre><h3 id="nginscript-与-javascript-的区别"><a href="#nginscript-与-javascript-的区别" class="headerlink" title="nginscript 与 javascript 的区别"></a>nginscript 与 javascript 的区别</h3><p>nginscript 不是完整的 javascript，它只是是实现了一个 ECMAScript 的一个子集， 为了追求效率， 许多 javascript 的内置对象在 nginscript 中并没有实现。我尝试使用了一下 Date、JSON 等对象，都还没有实现。</p>
<p>这便是几乎所有的 nginscript 知识，虽然没有实现完整的 EMCAScript 规范，但是对于配置 nginx 来说，个人感觉也够用了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上个月的 nginx.conf 2015 大会上， 官方宣布已经支持通过 javascript 代码来配置 nginx，并把这个实现称命名为——nginscript。使用 nginscript，可以很轻易得在 niginx 配置文件中通过 js 语法来实现自定义的服务器配置。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;# 下载最新版本的 nginx 并解压
curl -O http://nginx.org/download/nginx-1.9.5.tar.gz
tar -xzvf nginx-1.9.5.tar.gz

# 下载 nginscript 模块并解压
curl -O http://hg.nginx.org/njs/archive/tip.tar.gz
tar -xzvf tip.tar.gz

# 编译并安装 nginx
$ cd nginx-1.9.5
$ ./configure --add-module=刚才解压的nginscript目录
$ make
$ make install
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="javascript" scheme="http://annn.me/tag/javascript/"/>
    
      <category term="nginx" scheme="http://annn.me/tag/nginx/"/>
    
  </entry>
  
  <entry>
    <title>无梯子如何正常访问使用了 googleapis 的网站</title>
    <link href="http://annn.me/reres-googleapis/"/>
    <id>http://annn.me/reres-googleapis/</id>
    <published>2015-09-11T05:22:51.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多国外的网站都使用被墙掉的 googleapis.com 上的静态资源（如 font、js库 等），如果不爬墙，这些资源无法加载，导致网站无法正常访问。</p>
<p>其实，360提供了一个国内的 googleapis.com 镜像仓库（<a href="http://libs.useso.com/" target="_blank" rel="external">libs.useso.com</a>）。我想，当遇到 googleapis 的请求时，浏览器能自动跳转到360的镜像，就能正常访问了。</p>
<p>正好，我以前写过一个 chrome 插件 <a href="https://github.com/hanan198501/ReRes" target="_blank" rel="external">ReRes</a>，可以通过它来完成这项工作。</p>
<p>安装好 ReRes 后，添加一条规则：</p>
<pre><code>If URL match：^http\:\/\/(.+?)\.googleapis\.com\/(.+?)$
Response：http://$1.useso.com/$2
</code></pre><p>当浏览器中的请求匹配到 ^http\:\/\/(.+?).googleapis.com\/(.+?)$ 这个正则时，会自动跳转到 <a href="http://$1.useso.com/$2" target="_blank" rel="external">http://$1.useso.com/$2</a> 这个 url ，其中 $1 和 $2 分别是正则中捕获到的两个分组。</p>
<p>如此，就可以正常访问使用了 googleapis 的网站。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多国外的网站都使用被墙掉的 googleapis.com 上的静态资源（如 font、js库 等），如果不爬墙，这些资源无法加载，导致网站无法正常访问。&lt;/p&gt;
&lt;p&gt;其实，360提供了一个国内的 googleapis.com 镜像仓库（&lt;a href=&quot;http://l
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="javascript" scheme="http://annn.me/tag/javascript/"/>
    
      <category term="ReRes" scheme="http://annn.me/tag/ReRes/"/>
    
      <category term="googleapis" scheme="http://annn.me/tag/googleapis/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个 CMD 模块加载器</title>
    <link href="http://annn.me/how-to-realize-cmd-loader/"/>
    <id>http://annn.me/how-to-realize-cmd-loader/</id>
    <published>2015-09-03T09:03:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>cmd 是阿里大神玉伯提出的基于浏览器的前端模块化规范，并在 seajs 中实现了这个规范。相对于另一个在国外比较流行的前端模块化规范 amd，cmd 对于 nodejs 的使用者来说更加友好，使得类似 commonJS 模块的写法可以在浏览器中使用，同时解决了浏览器中模块异步加载的困扰。<br>关于 cmd 更详细的内容可以移步 <a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="external">https://github.com/cmdjs/specification/blob/master/draft/module.md</a><br>今天，我们一起来学习如何实现一个浏览器端的简单的 cmd loader。</p>
<h2 id="模块加载流程"><a href="#模块加载流程" class="headerlink" title="模块加载流程"></a>模块加载流程</h2><p>下图展示了一个 cmd loader 的模块加载大体流程：</p>
<p><img src="/assets/img/cmd.png" alt="cmd loader"></p>
<ol>
<li>首先，通过 use 方法来加载入口模块，并接收一个回调函数， 当模块加载完成， 会调用回调函数，并传入对应的模块。use 方法会 check 模块有没有缓存，如果有，则从缓存中获取模块，如果没有，则创建并加载模块。</li>
<li>获取到模块后，模块可能还没有 load 完成，所以需要在模块上绑定一个 “complete” 事件，模块加载完成会触发这个事件，这时候才调用回调函数。</li>
<li>创建一个模块时，id就是模块的地址，通过创建 script 标签的方式异步加载模块的代码（factory），factory 加载完成后，会 check factory 中有没有 require 别的子模块:<ul>
<li>如果有，继续加载其子模块，并在子模块上绑定 “complete” 事件，来触发本身 的 “complete” 事件；</li>
<li>如果没有则直接触发本身的 “complete” 事件。</li>
</ul>
</li>
<li>如果子模块中还有依赖，则会递归这个过程。</li>
<li>通过事件由里到外的传递，当所有依赖的模块都 complete 的时候，最外层的入口模块才会触发 “complete” 事件，use 方法中的回调函数才会被调用。</li>
</ol>
<a id="more"></a>
<h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><p>理解了整个过程，那么我们就来开始实现我们的代码，我们暂且给这个加载器命名为 mcmd 吧。首先是加载器的功能模块划分：</p>
<p><img src="/assets/img/cmd-modules.png" alt="cmd loader"></p>
<ul>
<li>mcmd：入口文件，用于定义默认配置，参数，常量等，同时使用或加载其他的功能模块；</li>
<li>define：实现 cmd 中的 “define” 方法；</li>
<li>require：实现 cmd 中的 “require” 方法；</li>
<li>use：实现 cmd 中的 “use” 方法；</li>
<li>module：模块类，实现模块的创建、加载、事件等功能；</li>
<li>load：用于获取模块，把模块从新建和从 cache 中获取封装成统一的接口；</li>
<li>promise：异步任务处理器；</li>
<li>util：工具类函数；</li>
</ul>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>我们使用 commonJS 的方式进行编码，并使用 browserify 配合 gulp 来构建我们的项目。</p>
<pre><code>var gulp = require(&apos;gulp&apos;);
var uglify = require(&apos;gulp-uglify&apos;);
var concat = require(&apos;gulp-concat&apos;);
var browserify = require(&apos;browserify&apos;);
var source = require(&apos;vinyl-source-stream&apos;);
var buffer = require(&apos;vinyl-buffer&apos;)

var pg = require(&apos;./package&apos;);
var versionName = pg.name + &apos;.&apos; + pg.version

gulp.task(&apos;default&apos;, [&apos;build&apos;]);

gulp.task(&apos;build&apos;, function () {
    browserify(&apos;./src/mcmd.js&apos;)
        .bundle()
        .pipe(source(versionName))
        .pipe(buffer())
        .pipe(concat(versionName + &apos;.js&apos;))
        .pipe(gulp.dest(&apos;./prd&apos;))
        .pipe(uglify())
        .pipe(concat(versionName + &apos;.min.js&apos;))
        .pipe(gulp.dest(&apos;./prd&apos;));
});
</code></pre><p>确定好了功能划分和构建方式，下面我们就来实现每一个功能模块：</p>
<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>将我们的 cmd loader 挂在 window.mcmd 上，把 define 方法也挂在 window.define 上，初始化其他的方法和配置。</p>
<pre><code>var g = window;
g.define = require(&apos;./define&apos;);
g.mcmd = {
    use: require(&apos;./use&apos;),
    require: require(&apos;./require&apos;),

    // 模块缓存
    modules: {},

    // 默认配置
    config: {
        root: &apos;/&apos;
    },

    // 修改配置
    setConfig: function (obj) {
        for (var key in obj) {
            this.config[key] = obj[key];
        }
    },

    // 模块状态常量
    MODULE_STATUS: {
        PENDDING: 0,
        LOADING: 1,
        COMPLETED: 2,
        ERROR: 3
    }
};
</code></pre><h2 id="use-js"><a href="#use-js" class="headerlink" title="use.js"></a>use.js</h2><p>实现了 mcmd.use 方法，接收两个参数，第一个是id或者id数组，第二个是回调函数。内部会使用 load.js 来获取模块，并通过 promise 来处理获取多个模块的并发异步场景。</p>
<pre><code>var Promise = require(&apos;./promise&apos;);
var load = require(&apos;./load&apos;);

module.exports = function use(ids, callback) {

    if (!Array.isArray(ids)) {
        ids = [ids]
    }

    Promise.all(ids.map(function (id) {
        return load(mcmd.config.root + id);
    })).then(function (list) {
        if (typeof callback === &apos;function&apos;) {
            callback.apply(window, list);
        }
    }, function (errorInfo) {
        throw errorInfo;
    });
}
</code></pre><h2 id="load-js"><a href="#load-js" class="headerlink" title="load.js"></a>load.js</h2><p>获取一个模块，并绑定事件，接收两个参数，一个是模块id，一个是回调函数，并返回一个 promise 对象。当模块 complete（加载完成）时，执行回调，同时 resolve 返回的 promise 对象。</p>
<pre><code>var Promise = require(&apos;./promise&apos;);
var Module = require(&apos;./module&apos;);
var util = require(&apos;./util&apos;);

module.exports = function (id, callback) {
    return new Promise(function (resolve, reject) {
        var mod =  mcmd.modules[id] || Module.create(id);
        mod.on(&apos;complete&apos;, function () {
            var exp = util.getModuleExports(mod);
            if (typeof callback === &apos;function&apos;) {
                callback(exp);
            }
            resolve(exp);
        });
        mod.on(&apos;error&apos;, reject);
    });
}
</code></pre><h2 id="promise-js"><a href="#promise-js" class="headerlink" title="promise.js"></a>promise.js</h2><p>详见： <a href="/ecmascript6-promise">/ecmascript6-promise</a></p>
<h2 id="module-js"><a href="#module-js" class="headerlink" title="module.js"></a>module.js</h2><p>模块的构造函数，实现了模块的创建，加载，事件传递，状态维护等。</p>
<pre><code>// 构造函数
function Module(id) {
    mcmd.modules[id] = this; // 缓存模块
    this.id = id;
    this.status = mcmd.MODULE_STATUS.PENDDING; // 状态
    this.factory = null;    // 执行代码
    this.dependences = null;    //依赖
    this.callbacks = {};    // 绑定的事件回调函数
    this.load();
}

// 静态方法创建模块
Module.create = function (id) {
    return new Module(id);
}

// 通过创建 script 标签异步加载模块
Module.prototype.load = function () {
    var id = this.id;
    var script = document.createElement(&apos;script&apos;);
    script.src = id;
    script.onerror = function (event) {
        this.setStatus(mcmd.MODULE_STATUS.ERROR, {
            id: id,
            error: (this.error = new Error(&apos;module can not load.&apos;))
        });
    }.bind(this);
    document.head.appendChild(script);
    this.setStatus(mcmd.MODULE_STATUS.LOADING);
}

// 事件绑定方法
Module.prototype.on = function (event, callback) {
    (this.callbacks[event] || (this.callbacks[event] = [])).push(callback);
    if (
        (this.status === mcmd.MODULE_STATUS.LOADING &amp;&amp; event === &apos;load&apos;) ||
        (this.status === mcmd.MODULE_STATUS.COMPLETED &amp;&amp; event === &apos;complete&apos;)
    ) {
        callback(this);
    }
    if (this.status === mcmd.MODULE_STATUS.ERROR &amp;&amp; event === &apos;error&apos;) {
        callback(this, this.error);
    }
}

// 事件触发方法
Module.prototype.fire = function (event, arg) {
    (this.callbacks[event] || []).forEach(function (callback) {
        callback(arg || this);
    }.bind(this));
}

// 设置状态方法，并抛出相应的事件
Module.prototype.setStatus = function (status, info) {
    if (this.status !== status) {
        this.status = status;
        switch (status) {
            case mcmd.MODULE_STATUS.LOADING:
                this.fire(&apos;load&apos;);
                break;
            case mcmd.MODULE_STATUS.COMPLETED:
                this.fire(&apos;complete&apos;);
                break;
            case mcmd.MODULE_STATUS.ERROR:
                this.fire(&apos;error&apos;, info);
                break;
            default:
                break;
        }
    }
}

module.exports = Module;
</code></pre><h2 id="define-js"><a href="#define-js" class="headerlink" title="define.js"></a>define.js</h2><p>实现 window.define 方法。接收一个参数 factory（cmd规范中不止一个，为了保持简单，我们只实现一个），即模块的代码包裹函数。通过 getCurrentScript 这个函数获取到当前执行脚本的 script 节点 src ，提取出模块 id ，找到模块对象。然后提取出 factory 中的依赖子模块，如果没有依赖，则直接触发模块的 “complete” 事件， 如果有依赖，则创建依赖的模块，绑定事件并加载，等依赖的模块加载完成后，再触发 “complete” 事件。</p>
<pre><code>var util = require(&apos;./util&apos;);
var Promise = require(&apos;./promise&apos;);
var Module = require(&apos;./module&apos;);

module.exports = function (factory) {
    var id = getCurrentScript().replace(location.origin, &apos;&apos;);
    var mod = mcmd.modules[id];
    var dependences = mod.dependences = getDenpendence(factory.toString());
    mod.factory = factory;
    if (dependences) {
        Promise.all(dependences.map(function (id) {
            return new Promise(function (resolve, reject) {
                id = mcmd.config.root + id;
                var depMode = mcmd.modules[id] || Module.create(id);
                depMode.on(&apos;complete&apos;, resolve);
                depMode.on(&apos;error&apos;, reject);
            });
        })).then(function () {
            mod.setStatus(mcmd.MODULE_STATUS.COMPLETED);
        }, function (error) {
            mod.setStatus(mcmd.MODULE_STATUS.ERROR, error);
        });
    }
    else {
        mod.setStatus(mcmd.MODULE_STATUS.COMPLETED);
    }
}

// 获取当前执行的script节点
// 参考 http://www.cnblogs.com/rubylouvre/archive/2013/01/23/2872618.html
function getCurrentScript() {
    var doc = document;
    if(doc.currentScript) {
        return doc.currentScript.src;
    }
    var stack;
    try {
        a.b.c();
    } catch(e) {
        stack = e.stack;
        if(!stack &amp;&amp; window.opera){
            stack = (String(e).match(/of linked script \S+/g) || []).join(&quot; &quot;);
        }
    }
    if(stack) {
        stack = stack.split( /[@ ]/g).pop();
        stack = stack[0] == &quot;(&quot; ? stack.slice(1,-1) : stack;
        return stack.replace(/(:\d+)?:\d+$/i, &quot;&quot;);
    }
    var nodes = head.getElementsByTagName(&quot;script&quot;);
    for(var i = 0, node; node = nodes[i++];) {
        if(node.readyState === &quot;interactive&quot;) {
            return node.className = node.src;
        }
    }
}

// 解析依赖，这里只做简单的提取，实际需要考虑更多情况，参考seajs
function getDenpendence(factory) {
    var list = factory.match(/require\(.+?\)/g);
    if (list) {
        list = list.map(function (dep) {
            return dep.replace(/(^require\([&apos;&quot;])|([&apos;&quot;]\)$)/g, &apos;&apos;);
        });
    }
    return list;
}
</code></pre><h2 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h2><p>返回模块的 exports 属性， 这里通过封装的 util.getModuleExports 方法获取并返回。</p>
<pre><code>var util = require(&apos;./util&apos;);

module.exports = function (id) {
    id = mcmd.config.root + id;
    var mod = mcmd.modules[id];
    if (mod) {
        return util.getModuleExports(mod);
    }
    else {
        throw &apos;can not get module by from:&apos; + id;
    }
}

module.exports.async = function (ids, callback) {
    mcmd.use(ids, callback);
}
</code></pre><h2 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a>util.js</h2><p>这里只有一个 getModuleExports 方法， 接收一个模块，返回模块的接口。当模块的 exports 属性不存在时，说明模块的 factory 没有被执行过。这时我们需要执行下 factory，传入 require， 创建的exports，以及 module 本身作为参数。最后获取模块的暴露的数据并返回。</p>
<pre><code>module.exports = {
    getModuleExports: function (mod) {
        if (!mod.exports) {
            mod.exports = {};
            mod.factory(mcmd.require, mod.exports, mod);
        }
        return mod.exports;
    }
};
</code></pre><p>这样，整个 cmd loader 就基本完成了。这只是一个非常基础的模块加载器，主要是为了理解 cmd 的原理和实现方式，对于生产环境，推荐使用成熟的 seajs。</p>
<p>整个 mcmd 项目我都放在了 github 上，大家可以去看看：<a href="https://github.com/hanan198501/mcmd" target="_blank" rel="external">https://github.com/hanan198501/mcmd</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cmd 是阿里大神玉伯提出的基于浏览器的前端模块化规范，并在 seajs 中实现了这个规范。相对于另一个在国外比较流行的前端模块化规范 amd，cmd 对于 nodejs 的使用者来说更加友好，使得类似 commonJS 模块的写法可以在浏览器中使用，同时解决了浏览器中模块异步加载的困扰。&lt;br&gt;关于 cmd 更详细的内容可以移步 &lt;a href=&quot;https://github.com/cmdjs/specification/blob/master/draft/module.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/cmdjs/specification/blob/master/draft/module.md&lt;/a&gt;&lt;br&gt;今天，我们一起来学习如何实现一个浏览器端的简单的 cmd loader。&lt;/p&gt;
&lt;h2 id=&quot;模块加载流程&quot;&gt;&lt;a href=&quot;#模块加载流程&quot; class=&quot;headerlink&quot; title=&quot;模块加载流程&quot;&gt;&lt;/a&gt;模块加载流程&lt;/h2&gt;&lt;p&gt;下图展示了一个 cmd loader 的模块加载大体流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/cmd.png&quot; alt=&quot;cmd loader&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，通过 use 方法来加载入口模块，并接收一个回调函数， 当模块加载完成， 会调用回调函数，并传入对应的模块。use 方法会 check 模块有没有缓存，如果有，则从缓存中获取模块，如果没有，则创建并加载模块。&lt;/li&gt;
&lt;li&gt;获取到模块后，模块可能还没有 load 完成，所以需要在模块上绑定一个 “complete” 事件，模块加载完成会触发这个事件，这时候才调用回调函数。&lt;/li&gt;
&lt;li&gt;创建一个模块时，id就是模块的地址，通过创建 script 标签的方式异步加载模块的代码（factory），factory 加载完成后，会 check factory 中有没有 require 别的子模块:&lt;ul&gt;
&lt;li&gt;如果有，继续加载其子模块，并在子模块上绑定 “complete” 事件，来触发本身 的 “complete” 事件；&lt;/li&gt;
&lt;li&gt;如果没有则直接触发本身的 “complete” 事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果子模块中还有依赖，则会递归这个过程。&lt;/li&gt;
&lt;li&gt;通过事件由里到外的传递，当所有依赖的模块都 complete 的时候，最外层的入口模块才会触发 “complete” 事件，use 方法中的回调函数才会被调用。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="javascript" scheme="http://annn.me/tag/javascript/"/>
    
      <category term="cmd" scheme="http://annn.me/tag/cmd/"/>
    
      <category term="loader" scheme="http://annn.me/tag/loader/"/>
    
  </entry>
  
  <entry>
    <title>在 fis 项目中使用 react.js</title>
    <link href="http://annn.me/fis-react/"/>
    <id>http://annn.me/fis-react/</id>
    <published>2015-08-23T07:24:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>fis 具有非常灵活的插件扩展机制，对于 react 的 jsx 也有现成的 parser 插件可用。<br>通过几条简单的配置，就可以在你的 fis 项目中使用 react 了。 但是在使用过程中，有一些小坑还是需要注意的，在此记录一下。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><pre><code>npm install fis-parser-react -g
</code></pre><p>注意，如果你使用的 react 版本是 0.13.x， 则要安装另一个版本的插件：</p>
<pre><code>npm install fis-parser-react-0.13.x -g
</code></pre><h2 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h2><p>编辑 fis-conf.js 文件， 加入以下内容：</p>
<pre><code>// 将 jsx 文件作为文本处理
fis.config.set(&apos;project.fileType.text&apos;, &apos;jsx&apos;);

// 后缀名为 jsx 的文件用 fis-parser-react 插件编译
// 如果你使用的 react 版本是 0.13.x，将下面第二个参数换成 &apos;react-0.13.x&apos;
fis.config.set(&apos;modules.parser.jsx&apos;, &apos;react&apos;);

// 将 jsx 文件编译结果输出为 js 文件
fis.config.set(&apos;roadmap.ext.jsx&apos;, &apos;js&apos;);
</code></pre><h2 id="模块化配置"><a href="#模块化配置" class="headerlink" title="模块化配置"></a>模块化配置</h2><p>默认情况，fis 不会将 widget 目录下的 jsx 文件包裹成 cmd 模块， 而是直接输出编译后的 js 文件。<br>但是我们更希望遵循 fis 的目录规范，将 widget 目录下的 jsx 文件也输出为 module， 所以我们还需要配置一下 roadmap.path。<br>编辑 fis-conf.js 文件， 加入以下内容：</p>
<pre><code>fis.config.set(&apos;roadmap.path&apos;, [{
    reg: /^\/widget\/(.*)\.jsx$/i,
    useMap: true,
    useHash: true,
    isMod: true,
    release: &apos;${statics}/${namespace}/widget/$1.js&apos;
}].concat(fis.config.get(&apos;roadmap.path&apos;, [])));
</code></pre><p>最后执行 fis release 就可以看到所有的 jsx 都可以被正确编译和引用到了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fis 具有非常灵活的插件扩展机制，对于 react 的 jsx 也有现成的 parser 插件可用。&lt;br&gt;通过几条简单的配置，就可以在你的 fis 项目中使用 react 了。 但是在使用过程中，有一些小坑还是需要注意的，在此记录一下。&lt;/p&gt;
&lt;h2 id=&quot;安装插件
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="javascript" scheme="http://annn.me/tag/javascript/"/>
    
      <category term="fis" scheme="http://annn.me/tag/fis/"/>
    
      <category term="react" scheme="http://annn.me/tag/react/"/>
    
  </entry>
  
  <entry>
    <title>caniuse 命令行工具</title>
    <link href="http://annn.me/caniuse-cmd/"/>
    <id>http://annn.me/caniuse-cmd/</id>
    <published>2015-07-28T14:26:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>大名鼎鼎的 <a href="http://caniuse.com/" target="_blank" rel="external">caniuse.com</a> 相信每个前端同学都不陌生.<br>这款查询浏览器兼容性的利器, 现在可以在命令行下使用了. 相比每次打开网站查询, 命令行确实方便许多哦.</p>
<p>首先,安装 caniuse 命令:</p>
<pre><code>npm install -g caniuse-cmd
</code></pre><p>然后在命令行就可以使用 caniuse 这一命令了, 后面跟你要查询的特性就行:</p>
<p><img src="/assets/img/caniuse1.png" alt="caniuse"></p>
<p>附项目的github: <a href="https://github.com/sgentle/caniuse-cmd" target="_blank" rel="external">https://github.com/sgentle/caniuse-cmd</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大名鼎鼎的 &lt;a href=&quot;http://caniuse.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;caniuse.com&lt;/a&gt; 相信每个前端同学都不陌生.&lt;br&gt;这款查询浏览器兼容性的利器, 现在可以在命令行下使用了. 相比每次打开网站
    
    </summary>
    
      <category term="工具" scheme="http://annn.me/categorie/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="caniuse" scheme="http://annn.me/tag/caniuse/"/>
    
  </entry>
  
  <entry>
    <title>使用 imitator 实现前后端分离开发中的数据模拟与静态资源映射</title>
    <link href="http://annn.me/imitator/"/>
    <id>http://annn.me/imitator/</id>
    <published>2015-07-27T09:53:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>imitator 是一个简单易用的 nodejs 服务器, 主要用于模拟 HTTP 接口数据, 请求代理与转发 。<br>使用imitator，可以解决前后端分离开发中的痛点之一：数据模拟，也可以作为代理服务器与静态资源服务器使用。</p>
<p>github: <a href="https://github.com/hanan198501/imitator" target="_blank" rel="external">https://github.com/hanan198501/imitator</a></p>
<h3 id="为什么会有-imitator？"><a href="#为什么会有-imitator？" class="headerlink" title="为什么会有 imitator？"></a>为什么会有 imitator？</h3><p>最近几个java（前后端都在一个工程里）项目交接过来，没时间重构成fis项目，组里好多前端同学想搞分离开发。<br>我推荐了 nginx，有童鞋反应配置文件相对前端来说还是不够友好，而且有些个性的接口格式无法满足。<br>于是写了 imitator，使用 nodejs 并基于 express.js 实现， 配置文件相当简单， 而且易于订制，前端同学使用起来非常顺手。</p>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><ol>
<li><p>安装——首先你要先安装 nodejs 和 npm， 然后全局安装imitator。</p>
<pre><code>npm install imitator -g
</code></pre></li>
<li><p>编写配置文件——在你的用户目录(比如我的是/User/hanan)下新建一个名为 Imitatorfile.js 的文件（这是 imitator 的默认配置文件）， 内容如下。</p>
<pre><code>module.exports = function(imitator) {
    // 返回一个json
    imitator(&apos;/json&apos;, {name: &apos;hello world&apos;});
}
</code></pre></li>
<li><p>启动服务——命令行输入以下命令，启动 imitator server.</p>
<pre><code>imitator
</code></pre></li>
<li><p>浏览器访问 127.0.0.1:8888/json ， 将会看到：</p>
<pre><code>{&quot;name&quot;:&quot;hello world&quot;}
</code></pre></li>
</ol>
<a id="more"></a>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>imitator 命令接受2参数：</p>
<p>-p 设置 imitator server 的端口号，默认是8888。</p>
<p>-f 设置配置文件的路径，支持相对路径和绝对路径，默认为：用户目录/Imitatorfile.js 。</p>
<p>下面的命令将使用 9000 端口， /home/myconfig.js 这个文件作为配置文件来启动 imitator server 。</p>
<pre><code>imitator -p 9000 -f /home/myconfig.js
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>imitator 的配置文件是其实就是一个 nodejs 模块， module.exports 是一个函数，接受一个参数：imitator 。 通过调用 imitator(option) 来设置一条规则。<br>其中 option 是规则的参数对象。如：</p>
<pre><code>module.exports = function(imitator) {
    imitator({
        url: &apos;/json&apos;,   // 匹配的url
        result: {name: &apos;json test&apos;} // 返回的内容
    });
}
</code></pre><p>如上，当请求地址匹配到 /json 这个路径的时候，就会返回 {name: ‘json test’} 的json字符串。</p>
<p>当 option 中只包含 url，result 两个参数时，可以简写成 imitator(url, result) 的形式，上面的例子可以写成：</p>
<pre><code>module.exports = function(imitator) {
    imitator(&apos;/json&apos;, {name: &apos;json test&apos;});
}
</code></pre><h3 id="规则参数（option）"><a href="#规则参数（option）" class="headerlink" title="规则参数（option）"></a>规则参数（option）</h3><p>配置文件中可以通过 imitator(option) 来制定一条规则，其中参数对象包含以下属性：</p>
<h4 id="option-url"><a href="#option-url" class="headerlink" title="option.url"></a>option.url</h4><p>必填，设置请求的匹配模式，支持正则。如：</p>
<pre><code>module.exports = function(imitator) {

    imitator({
        url: &apos;/json&apos;,
        ……
    });

    imitator({
        url: /\/\d{1,3}/,  // 支持正则
        ……
    });
}
</code></pre><h4 id="option-result"><a href="#option-result" class="headerlink" title="option.result"></a>option.result</h4><p>必填，设置请求的返回内容，如果是一个 object 或者 array，将会被 JSON.stringify 后返回；如果是一个 function，将会接受 req 和 res 两个参数执行，可用于实现一些个性化的返回内容。如：</p>
<pre><code>module.exports = function(imitator) {

    imitator({
        ……
        result: &apos;my result&apos;,  //普通字符串
    });

    imitator({
        ……
        result: {name: &apos;json test&apos;}, //json
    });

    imitator({
        ……
        result: function (req, res) {  // 自定义内容
            if (req.param.name === &apos;hanan&apos;) {
                res.send(&apos;中年痴呆症患者&apos;);
            }
            else {
                res.send(&apos;i do not know .&apos;);
            }
        },
    });
}
</code></pre><h4 id="option-type"><a href="#option-type" class="headerlink" title="option.type"></a>option.type</h4><p>设置通过 <a href="https://github.com/broofa/node-mime?_ga=1.127462925.164520609.1437794879#mimelookuppath" target="_blank">mime.lookup()</a> 转化的 Content-Type HTTP header。如：</p>
<pre><code>module.exports = function(imitator) {

    imitator({
        ……
        type: &apos;json&apos;,  ==&gt; &apos;application/json&apos;
        ……
    });

    imitator({
        ……
        type: &apos;html&apos;,  ==&gt; &apos;text/html&apos;
        ……
    });

}
</code></pre><h4 id="option-headers"><a href="#option-headers" class="headerlink" title="option.headers"></a>option.headers</h4><p>设置 HTTP header。如：</p>
<pre><code>module.exports = function(imitator) {

    imitator({
        ……
        headers: {
            myheadername: &apos;myheader value&apos;
        }
        ……
    });

}
</code></pre><h4 id="option-cookies"><a href="#option-cookies" class="headerlink" title="option.cookies"></a>option.cookies</h4><p>设置 cookie，如：</p>
<pre><code>module.exports = function(imitator) {

    imitator({
        ……
        cookies: [
            {name: &apos;myname&apos;, value: &apos;hanan&apos;, maxAge: 900000, httpOnly: true}
        ]
        ……
    });

}
</code></pre><h4 id="option-timeout"><a href="#option-timeout" class="headerlink" title="option.timeout"></a>option.timeout</h4><p>设置请求响应的延时时间，单位为毫秒，如：</p>
<pre><code>module.exports = function(imitator) {

     imitator({
         ……
         timeout: 1000
         ……
     });

}
</code></pre><h3 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h3><p>通过 imitator.base() 可以将规则之外的请求，转发到其他的服务器上。这样可以在实现接口模拟的同时，使用其他服务器的返回内容。如：</p>
<pre><code>module.exports = function(imitator) {

     // 这里是各种规则========
     imitator(……);
     imitator(……);
     imitator(……);


     // 没有命中规则的请求, 转发到192.168.8.8:9000下
     imitator.base(&apos;http://192.168.8.8:9000&apos;);
}
</code></pre><h3 id="静态目录"><a href="#静态目录" class="headerlink" title="静态目录"></a>静态目录</h3><p>通过 imitator.static(url, path) 可以设置静态文件目录。 url 为匹配的请求地址，支持正则；path 为静态文件的目录，路径相对于配置文件。如：</p>
<pre><code>module.exports = function(imitator) {

     imitator.static(&apos;static&apos;, &apos;./public&apos;);
}
</code></pre><h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><p>通过 imitator.file(filePath) 可以读取文件内容，filePath是文件路径，相对于配置文件。如：</p>
<pre><code>module.exports = function(imitator) {

    // 当请求匹配到 /file 时 ，返回文件 ./myfile.txt 的内容
    imitator(&apos;/file&apos;, imitator.file(&apos;./myfile.txt&apos;));
}
</code></pre><h3 id="配置文件-Imitatorfile-js-参考"><a href="#配置文件-Imitatorfile-js-参考" class="headerlink" title="配置文件(Imitatorfile.js)参考"></a>配置文件(Imitatorfile.js)参考</h3><p>详见：<a href="https://github.com/hanan198501/imitator/blob/master/test/Imitatorfile.js" target="_blank" rel="external">https://github.com/hanan198501/imitator/blob/master/test/Imitatorfile.js</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;imitator 是一个简单易用的 nodejs 服务器, 主要用于模拟 HTTP 接口数据, 请求代理与转发 。&lt;br&gt;使用imitator，可以解决前后端分离开发中的痛点之一：数据模拟，也可以作为代理服务器与静态资源服务器使用。&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/hanan198501/imitator&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/hanan198501/imitator&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么会有-imitator？&quot;&gt;&lt;a href=&quot;#为什么会有-imitator？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有 imitator？&quot;&gt;&lt;/a&gt;为什么会有 imitator？&lt;/h3&gt;&lt;p&gt;最近几个java（前后端都在一个工程里）项目交接过来，没时间重构成fis项目，组里好多前端同学想搞分离开发。&lt;br&gt;我推荐了 nginx，有童鞋反应配置文件相对前端来说还是不够友好，而且有些个性的接口格式无法满足。&lt;br&gt;于是写了 imitator，使用 nodejs 并基于 express.js 实现， 配置文件相当简单， 而且易于订制，前端同学使用起来非常顺手。&lt;/p&gt;
&lt;h3 id=&quot;快速上手&quot;&gt;&lt;a href=&quot;#快速上手&quot; class=&quot;headerlink&quot; title=&quot;快速上手&quot;&gt;&lt;/a&gt;快速上手&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装——首先你要先安装 nodejs 和 npm， 然后全局安装imitator。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install imitator -g
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写配置文件——在你的用户目录(比如我的是/User/hanan)下新建一个名为 Imitatorfile.js 的文件（这是 imitator 的默认配置文件）， 内容如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(imitator) {
    // 返回一个json
    imitator(&amp;apos;/json&amp;apos;, {name: &amp;apos;hello world&amp;apos;});
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动服务——命令行输入以下命令，启动 imitator server.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;imitator
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器访问 127.0.0.1:8888/json ， 将会看到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;hello world&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="imitator" scheme="http://annn.me/tag/imitator/"/>
    
      <category term="nodejs" scheme="http://annn.me/tag/nodejs/"/>
    
      <category term="server" scheme="http://annn.me/tag/server/"/>
    
      <category term="mock" scheme="http://annn.me/tag/mock/"/>
    
      <category term="http" scheme="http://annn.me/tag/http/"/>
    
      <category term="json" scheme="http://annn.me/tag/json/"/>
    
  </entry>
  
  <entry>
    <title>smarty 模板模板中的 assigin 函数</title>
    <link href="http://annn.me/smarty-assign/"/>
    <id>http://annn.me/smarty-assign/</id>
    <published>2015-06-21T14:23:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Smarty内置函数{assign}，在模板运行时为模板变量赋值，也可以为数组元素赋值，和在赋值时使用一些表达式。{$var=…}是{assign}函数的简写版。该函数有三个属性(var、value和scope)和一个选项标签(nocache)，其中var和value是必须使用的属性，分别用来设置要分配值的变量名和分配的值。而scope是可选属性，用来指定分配的变量范围，可以指定parent、root和global三个值，用来设定变量的有效范围。{assign}函数使用如下所示：</p>
<pre><code>{assign var=&quot;name&quot; value=&quot;brophp&quot;}  {*为变量$name赋值上brophp的值*}
{assign &quot;name&quot; &quot;brophp&quot;}            {*这是assign函数属性的简写*}
{$name=&quot;brophp&quot;}                    {*这是assign函数的简写，也是为变量$name赋值上brophp的值*}
</code></pre><p>在模板中声明的变量和从PHP中分配给模板中给模板的变量具有相同的使用方式。上例是在模板中声明一个$name变量三中书写方式：第一种是Smarty模板中标准函数的方式;第二种是省略属性名称简写的方式;第三种也是一种简写方法，更像是PHP变量的声明。除了上面简单声明一个变量以外，还可以为变量赋一些相对复杂的值，如使用数组和表达式，如下所示：</p>
<pre><code>{*定义数组*}
{assign var=foo value=[1,2,3]}          {*为变量$foo赋上一个索引数组值*}
{assign var=foo value=[&apos;y&apos;=&gt;&apos;yellow&apos;]}  {*为变量$foo赋上一个关联数组值*}
{assign var=foo value=[1,[9,8],3]}      {*可以使用嵌套声明多维数组*}
{assign var=foo value=$x+$y}            {*可以在属性中使用变量*}
{assign var=&quot;foo&quot; value=&quot;&apos;$foo+$bar&apos;&quot;}  {*可以在属性值的字符串中使用变量及表达式*}

{*短变量分配*}
{$foo=$bar+2}                       {*短变量分配值的方式*}
{$foo = strlen($bar)}               {*PHP函数在变量值中使用*}
{$foo = myfunct(($x+$y)*3)}         {*作为函数参数*}
{$foo.bar=1}                        {*数组元素赋值*}
{$foo.bar.baz=1}                    {*多维数组元素的赋值*}
{$foo[]=1}                          {*为数组添加新元素*}
{$foo[$x+3]}                        {*变量作为数组索引*}
{$foo={counter}+3}                  {*在标签里嵌套标签*}
{$foo=&quot;this is message{counter}&quot;}   {*在引号里使用标签*}
</code></pre><a id="more"></a>
<p>在载入模板中可见被载入模板(即为include进来)的分配变量。在声明变量时可以通过添加scope属性，并通过三个值来为调用的模板指定变量范围。</p>
<pre><code>{*bar只能在载入模板中可见*}
{assign var=&quot;bar&quot; value=&quot;value&quot;}

{*用了scope=parent，可以在自己和加载它的模板中可见*}
{assign var=&quot;foo&quot; value=&quot;something&quot; scope=parent}

{*全局变量在所有模板中可见*}
{assign var=&quot;foo&quot; value=&quot;bar&quot; scope=&quot;global&quot;}

{*你可以在当前树形结构的‘根’中赋值一个变量。该变量可以在所有使用该树形结构的模板中可见。*}
{assign var=&quot;foo&quot; value=&quot;bar&quot; scope=&quot;root&quot;}
</code></pre><p>除了使用内置函数{assign}和{$var=…}声明变量以外，还可以使用$Smarty的内置{append}函数，在模板执行期间建立或追加模板变量数组。如下所示：</p>
<pre><code>{append var=&apos;name&apos; value=&apos;Tom&apos;}                 {*类似于$name[]=&apos;Tom&apos;*}
{append var=&apos;name&apos; value=&apos;Bob&apos; index=&apos;first&apos;}   {*类似于$name.first=&apos;Bob&apos;*}
{append var=&apos;name&apos; value=&apos;Meyer&apos; index=&apos;last&apos; scope=&apos;parent&apos;}
</code></pre><p>内置函数{append}有两个必选属性，使用属性var指定一个数组变量名称，使用value属性向数组中添加值。也可以通过index属性指定索引下标，也和{assign}函数一样，可以使用scope属性设置变量作用域范围。</p>
<p>转自<a href="http://php.ncong.com/smarty/shengming_bianliang.html" target="_blank">http://php.ncong.com/smarty/shengming_bianliang.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Smarty内置函数{assign}，在模板运行时为模板变量赋值，也可以为数组元素赋值，和在赋值时使用一些表达式。{$var=…}是{assign}函数的简写版。该函数有三个属性(var、value和scope)和一个选项标签(nocache)，其中var和value是必须使用的属性，分别用来设置要分配值的变量名和分配的值。而scope是可选属性，用来指定分配的变量范围，可以指定parent、root和global三个值，用来设定变量的有效范围。{assign}函数使用如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{assign var=&amp;quot;name&amp;quot; value=&amp;quot;brophp&amp;quot;}  {*为变量$name赋值上brophp的值*}
{assign &amp;quot;name&amp;quot; &amp;quot;brophp&amp;quot;}            {*这是assign函数属性的简写*}
{$name=&amp;quot;brophp&amp;quot;}                    {*这是assign函数的简写，也是为变量$name赋值上brophp的值*}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在模板中声明的变量和从PHP中分配给模板中给模板的变量具有相同的使用方式。上例是在模板中声明一个$name变量三中书写方式：第一种是Smarty模板中标准函数的方式;第二种是省略属性名称简写的方式;第三种也是一种简写方法，更像是PHP变量的声明。除了上面简单声明一个变量以外，还可以为变量赋一些相对复杂的值，如使用数组和表达式，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{*定义数组*}
{assign var=foo value=[1,2,3]}          {*为变量$foo赋上一个索引数组值*}
{assign var=foo value=[&amp;apos;y&amp;apos;=&amp;gt;&amp;apos;yellow&amp;apos;]}  {*为变量$foo赋上一个关联数组值*}
{assign var=foo value=[1,[9,8],3]}      {*可以使用嵌套声明多维数组*}
{assign var=foo value=$x+$y}            {*可以在属性中使用变量*}
{assign var=&amp;quot;foo&amp;quot; value=&amp;quot;&amp;apos;$foo+$bar&amp;apos;&amp;quot;}  {*可以在属性值的字符串中使用变量及表达式*}

{*短变量分配*}
{$foo=$bar+2}                       {*短变量分配值的方式*}
{$foo = strlen($bar)}               {*PHP函数在变量值中使用*}
{$foo = myfunct(($x+$y)*3)}         {*作为函数参数*}
{$foo.bar=1}                        {*数组元素赋值*}
{$foo.bar.baz=1}                    {*多维数组元素的赋值*}
{$foo[]=1}                          {*为数组添加新元素*}
{$foo[$x+3]}                        {*变量作为数组索引*}
{$foo={counter}+3}                  {*在标签里嵌套标签*}
{$foo=&amp;quot;this is message{counter}&amp;quot;}   {*在引号里使用标签*}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="php" scheme="http://annn.me/categorie/php/"/>
    
    
      <category term="smarty" scheme="http://annn.me/tag/smarty/"/>
    
      <category term="assigin" scheme="http://annn.me/tag/assigin/"/>
    
  </entry>
  
  <entry>
    <title>新的 javascript Battery API</title>
    <link href="http://annn.me/battery/"/>
    <id>http://annn.me/battery/</id>
    <published>2015-02-24T12:43:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>javascript Battery 接口允许你通过 javascript 来获取电池的状态。</p>
<p><strong>navigator.getBattery()方法</strong></p>
<p>在新的标准里，电池的状态信息是通过navigator.getBattery()方法获取的。<br>navigator.getBattery()是一个异步方法，会返回一个es6标准的<a href="/ecmascript6-promise/">promise</a>对象。<br>所以我们获取电池状态的回调方法，必须通过该promise对象的then方法来注册：</p>
<pre><code>navigator.getBattery().then(function(result) {
    console.log(result);
});
</code></pre><p><strong>BatteryManager接口</strong></p>
<p>上个例子里的result是一个表示电池状态的对象， 它是由BatteryManager接口实现的，具有如下属性：</p>
<a id="more"></a>
<pre><code>{
    charging: false,                // 是否正在充电
    chargingTime: Infinity,         // 剩余多少秒充满电。
    dischargingTime: 8940,          // 剩余多少秒放完电
    level: 0.59,                    // 电量比（当前电量/电池容量）
    onchargingchange: null,         // chargingchange事件的回调函数
    onchargingtimechange: null,     // chargingtimechange事件的回调函数
    ondischargingtimechange: null,  // dischargingtimechange事件的回调函数
    onlevelchange: null             // levelchange事件的回调函数
}
</code></pre><p><strong>事件</strong></p>
<p>当电池状态发生变化时，会相应地更新charging、chargingTime、dischargingTime、level等属性的值，并触发对应的事件：</p>
<ul>
<li>chargingchange事件： charging属性变化时触发</li>
<li>chargingtimechange事件： chargingTime属性变化时触发</li>
<li>dischargingtimechange事件： dischargingTime属性变化时触发</li>
<li>levelchange事件： level属性变化时触发</li>
</ul>
<p>可以直接挂载一个事件回调函数：</p>
<pre><code>navigator.getBattery().then(function(battery) {
    console.log(battery.level);
    // ... and any subsequent updates.
    battery.onlevelchange = function() {
        console.log(this.level);
    };
});
</code></pre><p>也可以通过addEventListener()方法监听事件：</p>
<pre><code>navigator.getBattery().then(function(battery) {
    console.log(battery.level);
    battery.addEventListener(&apos;levelchange&apos;, function() {
        console.log(this.level);
    });
});
</code></pre><p><strong>demo</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Battery Status API Example&lt;/title&gt;
&lt;script&gt;
    window.onload = function () {
    function updateBatteryStatus(battery) {
        document.querySelector(&apos;#charging&apos;).textContent = battery.charging ? &apos;charging&apos; : &apos;not charging&apos;;
        document.querySelector(&apos;#level&apos;).textContent = battery.level;
        document.querySelector(&apos;#dischargingTime&apos;).textContent = battery.dischargingTime / 60;
    }

    navigator.getBattery().then(function(battery) {
        // Update the battery status initially when the promise resolves ...
        updateBatteryStatus(battery);

        // .. and for any subsequent updates.
        battery.onchargingchange = function () {
            updateBatteryStatus(battery);
        };

        battery.onlevelchange = function () {
            updateBatteryStatus(battery);
        };

        battery.ondischargingtimechange = function () {
            updateBatteryStatus(battery);
        };
    });
    };
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;charging&quot;&gt;(charging state unknown)&lt;/div&gt;
    &lt;div id=&quot;level&quot;&gt;(battery level unknown)&lt;/div&gt;
    &lt;div id=&quot;dischargingTime&quot;&gt;(discharging time unknown)&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>参考文章:</strong></p>
<p><a href="http://www.w3.org/TR/battery-status/" target="_blank" rel="external">http://www.w3.org/TR/battery-status/</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript Battery 接口允许你通过 javascript 来获取电池的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;navigator.getBattery()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在新的标准里，电池的状态信息是通过navigator.getBattery()方法获取的。&lt;br&gt;navigator.getBattery()是一个异步方法，会返回一个es6标准的&lt;a href=&quot;/ecmascript6-promise/&quot;&gt;promise&lt;/a&gt;对象。&lt;br&gt;所以我们获取电池状态的回调方法，必须通过该promise对象的then方法来注册：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;navigator.getBattery().then(function(result) {
    console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;BatteryManager接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上个例子里的result是一个表示电池状态的对象， 它是由BatteryManager接口实现的，具有如下属性：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="AddJS" scheme="http://annn.me/tag/AddJS/"/>
    
      <category term="chorme" scheme="http://annn.me/tag/chorme/"/>
    
  </entry>
  
  <entry>
    <title>使用 AddJS 为网页自动添加自定义javascript脚本</title>
    <link href="http://annn.me/addjs/"/>
    <id>http://annn.me/addjs/</id>
    <published>2015-02-24T07:24:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>addJS是一个chrome插件。view in <a href="https://github.com/hanan198501/addjs" target="_blank" rel="external">github</a>。</p>
<p>在浏览网站的时候，常常会想自己写js操作一下页面的内容(比如：抓图片，提取下载链接，屏蔽广告什么的)。于是，就有了这个插件。</p>
<p>功能：自动在指定的url的网页中添加自定义的javascript脚本并运行。</p>
<p><strong>现在就开始使用AddJS</strong></p>
<p>首先从chrome商店安装AddJS： <a target="_black" href="https://chrome.google.com/webstore/detail/addjs/aoahkpekljaimojhfefaiibfdcnmlhdi?hl=zh-CN">https://chrome.google.com/webstore/detail/addjs/aoahkpekljaimojhfefaiibfdcnmlhdi?hl=zh-CN</a></p>
<p>或者下载安装：<a href="/assets/download/addjs.zip">/assets/download/addjs.zip</a></p>
<p>至此，AddJS就可以使用了。下面是一些基本功能的使用操作方法：</p>
<a id="more"></a>
<p><strong>添加脚本</strong></p>
<p>点击“添加脚本”按钮，输入以下信息，然后保存：</p>
<ul>
<li><strong>url</strong>： 一个url地址或正则表达式，当请求的URL与之匹配时，规则生效。（注意:如果是正则，不要填开头的<code>/</code>和结束的<code>/gi</code>，如<code>/.*/gi</code>请写成<code>.*</code>，并勾选后面的reg），</li>
<li><strong>script</strong>：js脚本的内容， 如果以<a href="http://或者file:///开头，则会以此为url加载对应地址的脚本。" target="_blank" rel="external">http://或者file:///开头，则会以此为url加载对应地址的脚本。</a></li>
</ul>
<p><strong>启动/禁用</strong></p>
<p>勾选/取消对应规则前面的勾选框即可。</p>
<p><strong>编辑规则</strong></p>
<p>鼠标移到响应规则上，点击“编辑”。</p>
<p><strong>删除规则</strong></p>
<p>鼠标移到响应规则上，点击“删除”。</p>
<p><strong>批量导入规则</strong></p>
<p>点击“管理规则”按钮进入管理页，点击顶部“导入”按钮，即可导入规则列表文件。规则列表文件是一个json文件，其格式如下：</p>
<pre lang="javascript" line="1">[
    {
        "req":"^https?:\\/\\/.*test.com",
        "res":"alert(111)",
        "reg": true,
        "checked":false
    },
    {
        "req":"http://hanan.com",
        "res":"/myscript.js",
        "reg": false,
        "checked":true
    }
]
</pre>

<p>其中相关字段含义如下：</p>
<ul>
<li><strong>req</strong>：规则需要匹配的url</li>
<li><strong>res</strong>：脚本内容或地址</li>
<li><strong>reg</strong>：是否正则匹配</li>
<li><strong>checked</strong>：是否启用</li>
</ul>
<p><strong>本插件开发过程中采用了以下开源项目，感谢支持：</strong></p>
<ul>
<li>LESS</li>
<li>Bootstrap</li>
<li>AngularJS</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;addJS是一个chrome插件。view in &lt;a href=&quot;https://github.com/hanan198501/addjs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在浏览网站的时候，常常会想自己写js操作一下页面的内容(比如：抓图片，提取下载链接，屏蔽广告什么的)。于是，就有了这个插件。&lt;/p&gt;
&lt;p&gt;功能：自动在指定的url的网页中添加自定义的javascript脚本并运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在就开始使用AddJS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先从chrome商店安装AddJS： &lt;a target=&quot;_black&quot; href=&quot;https://chrome.google.com/webstore/detail/addjs/aoahkpekljaimojhfefaiibfdcnmlhdi?hl=zh-CN&quot;&gt;https://chrome.google.com/webstore/detail/addjs/aoahkpekljaimojhfefaiibfdcnmlhdi?hl=zh-CN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者下载安装：&lt;a href=&quot;/assets/download/addjs.zip&quot;&gt;/assets/download/addjs.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至此，AddJS就可以使用了。下面是一些基本功能的使用操作方法：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="AddJS" scheme="http://annn.me/tag/AddJS/"/>
    
      <category term="chorme" scheme="http://annn.me/tag/chorme/"/>
    
  </entry>
  
  <entry>
    <title>命令行推送个人文档至kindle</title>
    <link href="http://annn.me/ksend/"/>
    <id>http://annn.me/ksend/</id>
    <published>2015-01-03T05:24:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天同事发了一本pdf格式的电子书，以往的方式，我都是登陆自己的qq邮箱，然后发pdf作为附件，推送到自己的kindle接收邮箱上。<br>突然觉得，其实nodejs应该有这样的命令行工具，可以一条命令搞定，于是在npm上搜索了一下，果然有一个叫“kindle”的包。<br>但是安装以后，总是推送失败，大概开了下源码，估计是作者使用的nodemailer组件做了不兼容升级导致。</p>
<p>于是，为了以后传文件到kindle时偷个懒，就自己动手写了一个命令行工具，名叫ksend（ <a href="https://github.com/hanan198501/ksend" target="_blank">https://github.com/hanan198501/ksend</a> ），简单好用。 O(∩_∩)O~</p>
<p><strong>使用指南</strong></p>
<ol>
<li><p>安装</p>
<pre><code>npm install ksend -g
</code></pre></li>
<li><p>设置默认发送邮箱，格式: 邮箱地址:密码</p>
<pre><code>ksend --from yourname@qq.com:yourpassword
</code></pre></li>
<li><p>推送，如下示例，推送 a.pdf 至 hanan@kindle.cn 这个kindle接收邮箱：</p>
<pre><code>ksend -m hanan@kindle.cn a.pdf
</code></pre><p> 以上命令，参数 -m 表示接收邮箱。自此，完成推送。</p>
</li>
</ol>
<p>如果脚得每次都要敲 -m 接收邮箱 麻烦，可以设置默认接收邮箱：</p>
<pre><code>ksend --to hanan@kindle.cn
</code></pre><p>这样，以后只需要如下命令即可推送：</p>
<pre><code>ksend a.pdf
</code></pre><p>也可以同时推送多个文档：</p>
<pre><code>ksend a.pdf b.pdf ../img/photo.jpg /Users/hanan/book/ooxx.txt
</code></pre><p>查看帮助：</p>
<pre><code>ksend --help
</code></pre><p>ps: 记得把发送邮箱添加到您的kindle已认可的发件人电子邮箱列表哦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天同事发了一本pdf格式的电子书，以往的方式，我都是登陆自己的qq邮箱，然后发pdf作为附件，推送到自己的kindle接收邮箱上。&lt;br&gt;突然觉得，其实nodejs应该有这样的命令行工具，可以一条命令搞定，于是在npm上搜索了一下，果然有一个叫“kindle”的包。&lt;br
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="ksend" scheme="http://annn.me/tag/ksend/"/>
    
      <category term="kindle" scheme="http://annn.me/tag/kindle/"/>
    
  </entry>
  
  <entry>
    <title>基于 postMessage 和 localStorage 的跨域本地存储方案</title>
    <link href="http://annn.me/cross-domain-local-storage/"/>
    <id>http://annn.me/cross-domain-local-storage/</id>
    <published>2014-09-07T12:38:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5 的 postMessage 为解决跨域页面通信提供了一套可控的机制， 而 localStorage 则提供了易用简洁的本地存储方案？<br>这两者结合起来，能否实现跨域本地存储呢 ？</p>
<p>答案是可以的。假设有 a.com 和 b.com 两个页面。我们想通过 a 页面去修改 b 页面的本地数据。 我们需要做如下步奏：</p>
<ul>
<li>在 a 页面创建一个 iframe ，嵌入 b 页面</li>
<li>a 页面通过 postMessage 传递指定格式的消息给 b 页面</li>
<li>b 页面解析 a 页面传递过来的消息内容，调用localStorage API 操作本地数据</li>
<li>b 页面包装 localStorage 的操作结果，并通过 postMessage 传递给 a 页面</li>
<li>a 页面解析 b 页面传递回来的消息内容，得到 localStorage 的操作结果</li>
</ul>
<p>整个过程如下图：</p>
<p><img style="mergin:5px;" src="/assets/img/cross-localstorage.png" alt=""></p>
<a id="more"></a>
<p>OK，清楚了整个过程，我们就可以封装出相应的组件：CSClient.js 和 csHub.js，来完成这个过程，下面我们来简单实现一下。</p>
<p>先来看CSClient.js，作用于 a 页面，用于创建跨域存储实例，它提供了 get、set、del 这三个方法来操作跨域的数据：</p>
<pre><code>function CSClient(url) {
    this.id = this._getId();
    this._init(url);
    this._origin = this._getOrigin(url);
    this._callbacks = {
        _get: {},
        _set: {},
        _del: {}
    }
    this._bindEvent();
}

CSClient.prototype._getId = function () {
    id = 0;
    return function () {
        return ++id;
    }
}();

CSClient.prototype._init = function (url) {
    var frame = document.createElement(&apos;iframe&apos;);
    frame.style.display = &apos;none&apos;;
    frame.src = url;
    document.body.appendChild(frame);
    this._hub = frame.contentWindow;
}

CSClient.prototype._getOrigin = function(url) {
    var uri, origin;
    uri = document.createElement(&apos;a&apos;);
    uri.href = url;
    origin = uri.protocol + &apos;//&apos; + uri.host;
    return origin;
};

CSClient.prototype._parseMessage = function (method, key, value) {
    return JSON.stringify({
        method: method,
        key: key,
        value: value
    });
}


CSClient.prototype._bindEvent = function () {
    var _this = this;
    window.addEventListener(&apos;message&apos;, function (event) {
        var data = JSON.parse(event.data);
        var error = data.error;
        var result = data.result  &amp;&amp; JSON.parse(data.result) || null;
        try {
            _this._callbacks[&apos;_&apos; + data.method][data.key](error, result);
        }
        catch (e){
            console.log(e);
        }
    }, false);
}

CSClient.prototype.get = function (key, callback) {
    this._hub.postMessage(this._parseMessage(&apos;get&apos;, key), this._origin);
    this._callbacks._get[key] = callback;
}

CSClient.prototype.set = function (key, value, callback) {
    this._hub.postMessage(this._parseMessage(&apos;set&apos;, key, value), this._origin);
    this._callbacks._set[key] = callback;
}

CSClient.prototype.del = function (key, callback) {
    this._hub.postMessage(this._parseMessage(&apos;del&apos;, key), this._origin);
    this._callbacks._del[key] = callback;
}
</code></pre><p>使用方法如下：</p>
<pre><code>var key = document.querySelector(&apos;#key&apos;);
var value = document.querySelector(&apos;#value&apos;);
var btn = document.querySelectorAll(&apos;button&apos;);
var storage = new CSClient(&apos;http://b.com&apos;);

btn[0].onclick = function (e) {
    storage.get(key.value, function (err, result) {
        if (err) {
            console.log(err);
            return;
        }
        console.log(result);
    })
}

btn[1].onclick = function (e) {
    storage.set(key.value, value.value, function (err) {
        if (err) {
            console.log(err);
            return;
        }
        console.log(&apos;set ok&apos;);
    })
}

btn[2].onclick = function (e) {
    storage.del(key.value, function (err) {
        if (err) {
            console.log(err);
            return;
        }
        console.log(&apos;del ok&apos;);
    })
}
</code></pre><p>接着看 csHub.js，作用于 b 页面，用于设置跨域存储的权限、接受 client 的消息、操作本地数据。只有拥有权限的 origin ，才能操作本页面的本地数据。</p>
<pre><code>var csHub = window.csHub = {
    init: function (origin) {
        this.originRule = origin;
    },

    get: function (key) {
        return JSON.stringify(window.localStorage.getItem(key));
    },

    set: function (key, value) {
        window.localStorage.setItem(key, JSON.stringify(value));
    },

    del: function (key) {
        window.localStorage.removeItem(key);
    }
};

window.addEventListener(&apos;message&apos;, function (event) {
    var message = JSON.parse(event.data), result, err = null;
    if (csHub.originRule.test(event.origin)) {
        try {
            result = csHub[message.method](message.key, message.value);
        }
        catch (e) {
            err = {
                message: e.message,
                stack: e.stack
            };
        }
        window.parent.postMessage(JSON.stringify({
            error: err,
            method: message.method,
            key: message.key,
            result: result
        }), event.origin);
    }
}, false);
</code></pre><p>使用方法如下：</p>
<pre><code>csHub.init(/a.com$/);
</code></pre><p>以上代码都比较简单， 主要为了演示如何实现跨域存储。如果你想在项目中使用此方案。推荐使用<a href="https://github.com/zendesk/cross-storage" target="_blank" rel="external">https://github.com/zendesk/cross-storage</a>这个库。<br>这个库实现了更灵活的权限机制，使用 ES6 的 promises 规范简化了操作接口， 并对浏览器的差异化做了处理，兼容到了 ie8+ 与其他现代浏览器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5 的 postMessage 为解决跨域页面通信提供了一套可控的机制， 而 localStorage 则提供了易用简洁的本地存储方案？&lt;br&gt;这两者结合起来，能否实现跨域本地存储呢 ？&lt;/p&gt;
&lt;p&gt;答案是可以的。假设有 a.com 和 b.com 两个页面。我们想通过 a 页面去修改 b 页面的本地数据。 我们需要做如下步奏：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 a 页面创建一个 iframe ，嵌入 b 页面&lt;/li&gt;
&lt;li&gt;a 页面通过 postMessage 传递指定格式的消息给 b 页面&lt;/li&gt;
&lt;li&gt;b 页面解析 a 页面传递过来的消息内容，调用localStorage API 操作本地数据&lt;/li&gt;
&lt;li&gt;b 页面包装 localStorage 的操作结果，并通过 postMessage 传递给 a 页面&lt;/li&gt;
&lt;li&gt;a 页面解析 b 页面传递回来的消息内容，得到 localStorage 的操作结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;mergin:5px;&quot; src=&quot;/assets/img/cross-localstorage.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="cross" scheme="http://annn.me/tag/cross/"/>
    
      <category term="domain" scheme="http://annn.me/tag/domain/"/>
    
      <category term="local" scheme="http://annn.me/tag/local/"/>
    
      <category term="postMessage" scheme="http://annn.me/tag/postMessage/"/>
    
      <category term="storage" scheme="http://annn.me/tag/storage/"/>
    
  </entry>
  
  <entry>
    <title>如何绕过chrome的弹窗拦截机制</title>
    <link href="http://annn.me/open-window-in-chrome/"/>
    <id>http://annn.me/open-window-in-chrome/</id>
    <published>2014-07-04T12:38:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在chrome的安全机制里面，非用户触发的window.open方法，是会被拦截的。举个例子：</p>
<pre><code>var btn = $(&apos;#btn&apos;);
btn.click(function () {

    //不会被拦截
    window.open(&apos;http://cssha.com&apos;)
});
</code></pre><p>上面的代码中，window.open是用户触发的时候，是不会被拦截的，可以正常打开新窗口。再看下面这个：</p>
<pre><code>var btn = $(&apos;#btn&apos;);
btn.click(function () {

    $.ajax({
        url: &apos;ooxx&apos;,
        success: function (url) {

            //会被拦截
            window.open(url);
        }
    })
});
</code></pre><p>上面的代码中，用户没有直接出发window.open，而是发出一个ajax请求，window.open方法被放在了ajax的回调函数里，这样的情况是会被拦截的。</p>
<p>那么，当用户点击按钮，发出ajax请求，如何在ajax请求完成后再打开新窗口，又不被拦截呢？ 接着往下看：</p>
<pre><code>var btn = $(&apos;#btn&apos;);
btn.click(function () {

    //打开一个不被拦截的新窗口
    var newWindow = window.open();

    $.ajax({
        url: &apos;ooxx&apos;,
        success: function (url) {

            //修改新窗口的url
            newWindow.location.href = url;
        }
    })
});
</code></pre><p>上面的代码中，用户安点击按钮的时候，先打开一个空白页，再发ajax请求，在ajax回调里面修改新窗口的.location.href，这样就不会被拦截啦啦啦啦~~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在chrome的安全机制里面，非用户触发的window.open方法，是会被拦截的。举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var btn = $(&amp;apos;#btn&amp;apos;);
btn.click(function () {

    //不会被拦截
    wi
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="chrome" scheme="http://annn.me/tag/chrome/"/>
    
      <category term="javascript" scheme="http://annn.me/tag/javascript/"/>
    
      <category term="window" scheme="http://annn.me/tag/window/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个ECMAScript 6 的promise补丁</title>
    <link href="http://annn.me/ecmascript6-promise/"/>
    <id>http://annn.me/ecmascript6-promise/</id>
    <published>2014-06-04T12:38:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Promise最先是CommonJS工作组提出的一种规范之一，目的是为了解决js异步编程过程中，回调嵌套过深的问题。ECMAScript 6 规范化了Promise对象的语言接口，使其成了js的原生对象之一。</p>
<p>如果你还不了解ECMAScript 6 中的Promise对象，建议阅读<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank">http://es6.ruanyifeng.com/#docs/promise</a>。ECMAScript 6 中的Promise对象与一些常用的promise库（如jquery，when.js）中的实现略有不同，本文讨论的实现，以ECMAScript 6 为准。<br>下面，我们来一起学习，如何在不支持ES6的浏览器上简单实现Promise，如有不对的地方，还请多多指正。</p>
<h4 id="首先，我们来看看Promise构造函数。"><a href="#首先，我们来看看Promise构造函数。" class="headerlink" title="首先，我们来看看Promise构造函数。"></a>首先，我们来看看Promise构造函数。</h4><pre><code>var Promise = function (fun) {
        var me = this,
            resolve = function (val) {
                me.resolve(val);
            },
            reject = function (val) {
                me.reject(val);
            }
        me._st = &apos;pending&apos;;
        me._rsq = null;
        me._rjq = null;
        (typeof fun === &apos;function&apos;) &amp;&amp; fun(resolve, reject);
    },
    fn = Promise.prototype;
</code></pre><p>构造函数接受一个异步的回调函数，并调用，回调函数的2个参数，分别为异步操作成功和失败时候要调用的改变Promise实例状态的方法。<br>_st用于存放当前实例的状态，初始值为”pending”，异步操作成功为”resolve”，失败为”reject”。_rsq用于存放异步操作成功的回调，_rjq用于存放异步操作失败的回调。<br>同时，把Promise.prototype挂在变量fn上，接下我们只要给fn添加方法就可以了。</p>
<a id="more"></a>
<h4 id="then和-catch方法"><a href="#then和-catch方法" class="headerlink" title=".then和.catch方法"></a>.then和.catch方法</h4><pre><code>fn.then = function (resolve, reject) {
    var pms = new Promise();
    this._rsq = function (val) {
        var ret = resolve ? resolve(val) : val;
        if (ret instanceof Promise) {
            ret.then(function (val) {
                pms.resolve(val);
            });
        }
        else{
            pms.resolve(ret);
        }
    };
    this._rjq = function (val) {
        pms.reject(reject(val));
    };
    return pms;
}
fn.catch = function (reject) {
    return this.then(null, reject);
}
</code></pre><p>.then方法接受2个参数，成功回调和失败回调。then方法内部new了一个新的Promise对象pms并返回，从而实现链式调用。<br>并且给实例的_rsq和_rjq分别挂了2个函数，是成功和失败的回调函数的调用，并把返回值传给pms的resolve和reject方法，这样我们就完成了参数的传递功能。<br>注意，成功回调函数可能也会返回一个promise对象，因此，我们要对此情况做而外处理，给它新挂一个then调用，用于触发pms的成功回掉。<br>而.catch方法只是.then(null, reject)的一个别名，内部调一下即可。</p>
<h4 id="resolve和-reject方法"><a href="#resolve和-reject方法" class="headerlink" title=".resolve和.reject方法"></a>.resolve和.reject方法</h4><pre><code>fn.resolve = function (val) {
    if (this._st === &apos;resolved&apos; || this._st === &apos;pending&apos;) {
        this._st = &apos;resolved&apos;;
        this._rsq &amp;&amp; this._rsq(val);
    }
}

fn.reject = function (val) {
    if (this._st === &apos;rejected&apos; || this._st === &apos;pending&apos;) {
        this._st = &apos;rejected&apos;;
        this._rsq &amp;&amp; this._rjq(val);
    }
}


.resolve方法接受一个参数，为上个回调函数的返回值，或者是上个异步操作函数的reslve函数的参数值。如果实例的状态为resolved或者pending的时候，才调用.\_rsq方法。
.reject同理。


#### Promise.all静态方法


Promise.all = function (arr) {
    var pms = new Promise();
    var len = arr.length,
        i = 0,
        res = 0;
    while (i &lt; len) {
        arr[i].then(
            function () {
                if (++res === len) {
                    pms.resolve();
                }
            },
            function (val) {
                pms.reject(val);
            }
        );
        i++;
    }
    return pms;
}
</code></pre><p>Promise.all接受一个有promise对象的数组，并内部new了一个promise对象pms返回。当数组中所有的对象状态都成功的时候，执行pms.resolve()，即返回的promise对象状态变成resloved，<br>若数组有一个失败，则pms.reject(val)。</p>
<h4 id="Promise-resolve静态方法，这个好像没啥好讲的。"><a href="#Promise-resolve静态方法，这个好像没啥好讲的。" class="headerlink" title="Promise.resolve静态方法，这个好像没啥好讲的。"></a>Promise.resolve静态方法，这个好像没啥好讲的。</h4><pre><code>Promise.resolve = function (obj) {
    var pms = new Promise();
    if (obj &amp;&amp; typeof obj.then === &apos;function&apos;) {
        for (var i in pms) {
            obj[i] = pms[i];
        }
        return obj;
    }
    else {
        setTimeout(function () {
            pms.resolve(obj);
        });
        return pms;
    }
}
</code></pre><p>完整的代码，我放在<a href="https://github.com/hanan198501/promise" target="_blank" rel="external">https://github.com/hanan198501/promise</a>了，大家可以上去看看，也欢迎关注我的github。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise最先是CommonJS工作组提出的一种规范之一，目的是为了解决js异步编程过程中，回调嵌套过深的问题。ECMAScript 6 规范化了Promise对象的语言接口，使其成了js的原生对象之一。&lt;/p&gt;
&lt;p&gt;如果你还不了解ECMAScript 6 中的Promise对象，建议阅读&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot; target=&quot;_blank&quot;&gt;http://es6.ruanyifeng.com/#docs/promise&lt;/a&gt;。ECMAScript 6 中的Promise对象与一些常用的promise库（如jquery，when.js）中的实现略有不同，本文讨论的实现，以ECMAScript 6 为准。&lt;br&gt;下面，我们来一起学习，如何在不支持ES6的浏览器上简单实现Promise，如有不对的地方，还请多多指正。&lt;/p&gt;
&lt;h4 id=&quot;首先，我们来看看Promise构造函数。&quot;&gt;&lt;a href=&quot;#首先，我们来看看Promise构造函数。&quot; class=&quot;headerlink&quot; title=&quot;首先，我们来看看Promise构造函数。&quot;&gt;&lt;/a&gt;首先，我们来看看Promise构造函数。&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;var Promise = function (fun) {
        var me = this,
            resolve = function (val) {
                me.resolve(val);
            },
            reject = function (val) {
                me.reject(val);
            }
        me._st = &amp;apos;pending&amp;apos;;
        me._rsq = null;
        me._rjq = null;
        (typeof fun === &amp;apos;function&amp;apos;) &amp;amp;&amp;amp; fun(resolve, reject);
    },
    fn = Promise.prototype;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构造函数接受一个异步的回调函数，并调用，回调函数的2个参数，分别为异步操作成功和失败时候要调用的改变Promise实例状态的方法。&lt;br&gt;_st用于存放当前实例的状态，初始值为”pending”，异步操作成功为”resolve”，失败为”reject”。_rsq用于存放异步操作成功的回调，_rjq用于存放异步操作失败的回调。&lt;br&gt;同时，把Promise.prototype挂在变量fn上，接下我们只要给fn添加方法就可以了。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="javascript" scheme="http://annn.me/tag/javascript/"/>
    
      <category term="ecmascript" scheme="http://annn.me/tag/ecmascript/"/>
    
      <category term="promise" scheme="http://annn.me/tag/promise/"/>
    
  </entry>
  
  <entry>
    <title>Blog迁移到Github</title>
    <link href="http://annn.me/blog-move-to-github/"/>
    <id>http://annn.me/blog-move-to-github/</id>
    <published>2014-04-01T12:38:00.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于Wordpress主机到期，而且wp的markdown插件非常坑爹，经常把本来些的好好的md格式转得乱七八糟。于是花了一天时间，把Blog搬到github来了。使用了<a href="http://jekyllbootstrap.com" target="_blank" rel="external">Jekyll Bootstrap</a>框架，下面是折腾过程中的一些体会：</p>
<ul>
<li>文章迁移： wp后台把数据导出为xml文件，再用<a href="https://github.com/thomasf/exitwp" target="_blank" rel="external">exitwp</a>转成md。</li>
<li>评论迁移： Jekyll自带的disqus不太符合国情， 于是选择了国产的<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>。</li>
<li>代码高亮： 使用<a href="http://pygments.org/" target="_blank" rel="external">Pygments</a>。</li>
<li>文章摘要： Jekyll自带的显示摘要功能对HTML支持非常不好，我只好全文输出到一个script标签，再通过JS来截取并显示。</li>
<li>搜索文章： 尝试了google站内搜索，但是发现好多冗余的页面也被搜出来了，最后决定自己用JS来实现一个简单的，只针对文章标题进行匹配的搜索功能。</li>
</ul>
<p>迁移到Jekyll以后， 终于可以愉快地用md写blog了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于Wordpress主机到期，而且wp的markdown插件非常坑爹，经常把本来些的好好的md格式转得乱七八糟。于是花了一天时间，把Blog搬到github来了。使用了&lt;a href=&quot;http://jekyllbootstrap.com&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="服务器" scheme="http://annn.me/categorie/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="github" scheme="http://annn.me/tag/github/"/>
    
      <category term="jekyll" scheme="http://annn.me/tag/jekyll/"/>
    
  </entry>
  
  <entry>
    <title>WebStorm 8 新功能一览</title>
    <link href="http://annn.me/webstorm8/"/>
    <id>http://annn.me/webstorm8/</id>
    <published>2014-03-27T00:00:27.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="支持AngularJS"><a href="#支持AngularJS" class="headerlink" title="支持AngularJS"></a>支持AngularJS</h3><p>智能提示AngularJS指令（包括自定义指令），controller 和 application names以及花括号里边的数据绑定。 <img src="http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/angularJSSupport.png" alt=""></p>
<a id="more"></a>
<h3 id="支持-Spy-js"><a href="#支持-Spy-js" class="headerlink" title="支持 Spy-js"></a>支持 Spy-js</h3><p>通过Spy-js你可以看到触发代码执行的事件的完整列表，然后帮你整理堆栈跟踪事件，并在源代码中突出显示。 <img src="http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/spy-js.png" alt=""></p>
<h3 id="支持多个插入和选择"><a href="#支持多个插入和选择" class="headerlink" title="支持多个插入和选择"></a>支持多个插入和选择</h3><p>支持多个位置插入和选择。 <img src="http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/multipleCarets.gif" alt=""></p>
<h3 id="内置Grunt控制台"><a href="#内置Grunt控制台" class="headerlink" title="内置Grunt控制台"></a>内置Grunt控制台</h3><p>通过Grunt控制台可以列出并定义grunt任务的完整列表， 双击可执行。 <img src="http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/grunt-fullscreen.png" alt=""></p>
<h3 id="集成Bower"><a href="#集成Bower" class="headerlink" title="集成Bower"></a>集成Bower</h3><p>借助集成的Bower包管理器，你就可以更方便在项目中跟搜索，安装和管理客户端库和框架。 <img src="http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/bowerIntegration.png" alt=""></p>
<h3 id="支持javascript模块化"><a href="#支持javascript模块化" class="headerlink" title="支持javascript模块化"></a>支持javascript模块化</h3><p>完善了对RequireJS和AMD的支持程度，基于requirejs.config实现了源码导航功能。并改善了对Harmony module loader的支持。 <img src="http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/javascriptModules.png" alt=""></p>
<h3 id="Live-Console"><a href="#Live-Console" class="headerlink" title="Live Console"></a>Live Console</h3><p>在控制台中的javascript和Node.js的调试工具窗口现在可以作为一个shell提示符，并允许您执行命令和javascript代码。 <img src="http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/liveConsole.png" alt=""></p>
<h3 id="支持CucumberJS"><a href="#支持CucumberJS" class="headerlink" title="支持CucumberJS"></a>支持CucumberJS</h3><p>WebStorm现在了解CucumberJS的语法，可以帮助您生成代码步骤定义。您可以在一个单一的点击开始测试，看到一个不错的结构化格式的测试结果，并轻松导航到测试源。 <img src="http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/cucumberJS.png" alt=""></p>
<h3 id="下载Webstorm"><a href="#下载Webstorm" class="headerlink" title="下载Webstorm"></a>下载Webstorm</h3><p><a href="http://www.jetbrains.com/webstorm/" target="_blank" rel="external">http://www.jetbrains.com/webstorm</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;支持AngularJS&quot;&gt;&lt;a href=&quot;#支持AngularJS&quot; class=&quot;headerlink&quot; title=&quot;支持AngularJS&quot;&gt;&lt;/a&gt;支持AngularJS&lt;/h3&gt;&lt;p&gt;智能提示AngularJS指令（包括自定义指令），controller 和 application names以及花括号里边的数据绑定。 &lt;img src=&quot;http://www.jetbrains.com/webstorm/whatsnew/screenshots/80/angularJSSupport.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://annn.me/categorie/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="WebStorm" scheme="http://annn.me/tag/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title>发布grunt-cptpl插件</title>
    <link href="http://annn.me/grunt-cptpl/"/>
    <id>http://annn.me/grunt-cptpl/</id>
    <published>2014-03-15T23:25:43.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="view-on-Github：https-github-com-hanan198501-grunt-cptpl"><a href="#view-on-Github：https-github-com-hanan198501-grunt-cptpl" class="headerlink" title="view on Github：https://github.com/hanan198501/grunt-cptpl"></a>view on Github：<a href="https://github.com/hanan198501/grunt-cptpl" target="_blank" rel="external">https://github.com/hanan198501/grunt-cptpl</a></h4><p>grunt-cptpl插件可以将您的文本模板文件编译成javascript文件。在前端开发的时候，模板文本我们一般存放在一个隐藏dom节点，再通过javascript去获取这个节点的内容，将其编译。或者在写javascript的时候，我们手动通过拼接字符串的方式储存模板文本。grunt-cptpl使前端开发也可以像后端一样，把模板文本存放在单独的文件中，使我们的开发工作从繁琐的dom操作和拼串中解放出来，提高我们的开发效率。最主要的，模板文件作为单独文件存放，可以使我们的项目代码逻辑更加清晰，更具可维护性。</p>
<h5 id="grunt-cptpl都做了啥？"><a href="#grunt-cptpl都做了啥？" class="headerlink" title="grunt-cptpl都做了啥？"></a>grunt-cptpl都做了啥？</h5><p>grunt-cptpl会读取每个模板文件的文本内容，用指定模板引擎的预编译方法将其包裹起来，生成一个新的javascript文件。这个javascript文件文件里面的内容，其实就是模板引擎的预编译方法调用，传入的参数为模板文件的文本内容。这样我们就有了一个编译好的模板函数，要渲染的时候把数据传给它就好了。</p>
<a id="more"></a>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>这个插件需要 Grunt ~0.4.4</p>
<p>如果你还没有使用过<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>, 务必阅读一下它的<a href="http://gruntjs.com/getting-started" target="_blank" rel="external">入门</a>指南, 里面介绍了如何创建一个<a href="http://gruntjs.com/sample-gruntfile" target="_blank" rel="external">Grunt配置文件</a>以及如何安装和使用grunt插件。一旦你熟悉这个过程，你可以使用如下命令安装grunt-cptpl。</p>
<pre><code>npm install grunt-cptpl --save-dev
</code></pre><p>一旦插件被安装， 可以在Gruntfile里面添加如下代码来启用：</p>
<pre><code>grunt.loadNpmTasks(&apos;grunt-cptpl&apos;);
</code></pre><h2 id="配置-“cptpl”-task"><a href="#配置-“cptpl”-task" class="headerlink" title="配置 “cptpl” task"></a>配置 “cptpl” task</h2><h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><p>在项目的Gruntfile文件中， 有一个grunt.initConfig()方法， 在里面添加一个<code>cptpl</code>数据对象。 options为目标任务的自定义选项，选填。 files为文件列表的输出目录和对应的原文件列表。如下面代码里， <code>[&#39;test/html/abc.html&#39;, &#39;test/html/abc2.html&#39;， &#39;mytemplate/*&#39;]</code> 为原文件列表， <code>&#39;tmp/&#39;</code> 为输出的目录，支持通配符 <code>*</code>。</p>
<pre><code>grunt.initConfig({
    cptpl: {
        your_target: {
            options: {
                // 任务特定的选项放在这里
            },
            files: {
                // 目标特定的文件列表放在这里
                &apos;tmp/&apos;: [&apos;test/html/abc.html&apos;, &apos;test/html/abc2.html&apos;， &apos;mytemplate/*&apos;]
            }

        },
    },
});
</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="options-banner"><a href="#options-banner" class="headerlink" title="options.banner"></a>options.banner</h4><p>Type: <code>String</code> ， Default value: <code>&#39;&#39;</code></p>
<p>在生成的javascript文件开头写入的文本信息，通常为一段javascript注释文字，如 <code>/*BANNER*/</code></p>
<h4 id="options-engine"><a href="#options-engine" class="headerlink" title="options.engine"></a>options.engine</h4><p>Type: <code>String</code> ， Default value: <code>&#39;handlebars&#39;</code></p>
<p>指定模板引擎，内置支持的模板引擎有（不区分大小写）： <code>&#39;arTtemplate&#39;</code> 、 <code>&#39;handlebars&#39;</code> 、 <code>&#39;hogan&#39;</code> 、 <code>&#39;underscore&#39;</code> 、 <code>&#39;juicer&#39;</code> 、 <code>&#39;dot&#39;</code> 、 <code>&#39;kissy&#39;</code> 、 <code>&#39;baidutemplate&#39;</code>。</p>
<p>Example： 运行下面cptpl任务，将会把 <code>test/html/</code> 目录下的 <code>abc.html</code> 编译成 <code>abc.js</code> ， 存放在 <code>tmp/</code> 目录。</p>
<pre><code>cptpl: {
    test: {
        options: {
            banner: &apos;/*BANNER*/\n&apos;,
            engine: &apos;dot&apos;
        },
        files: {
            &apos;tmp/&apos;: [&apos;test/html/abc.html&apos;]
        }
    }
}
</code></pre><p>其中<code>abc.html</code> 和 <code>abc.js</code> 的内容如下：</p>
<pre><code>//abc.html中的内容：
&lt;h1&gt;{*title*}&lt;/h1&gt;
&lt;p&gt;{*content*}&lt;/p&gt;


//编译后，abc.js中的内容：
/*BANNER*/
;window.abc = doT.template(&apos;&lt;h1&gt;{*title*}&lt;/h1&gt;&lt;p&gt;{*content*}&lt;/p&gt;&apos;);
</code></pre><h4 id="options-context"><a href="#options-context" class="headerlink" title="options.context"></a>options.context</h4><p>Type: <code>String</code> ， Default value: <code>&#39;window&#39;</code></p>
<p>指定生成的javascript文件中编译好的模板函数的上下文对象， 如果此选项的值为 <code>&#39;{AMD}&#39;</code>，则把编译好的模板函数包装成一个AMD模块，如果此选项的值为 <code>&#39;{CMD}&#39;</code>， 则把编译好的模板函数包装成一个CMD模块。</p>
<p>Example：</p>
<pre><code>cptpl: {
    test: {
        options: {
            engine: &apos;dot&apos;,
            context: &apos;myObj&apos;
        },
        files: {
            &apos;tmp/&apos;: [&apos;test/html/abc.html&apos;]
        }
    }
}

// context: &apos;myObj&apos;
// abc.js ==&gt;
;myObj.abc = doT.template(&apos;&lt;h1&gt;{*title*}&lt;/h1&gt;&lt;p&gt;{*content*}&lt;/p&gt;&apos;);


// context: &apos;{AMD}&apos;
// abc.js ==&gt;
;define(function() {
    return doT.template(&apos;&lt;h1&gt;{*title*}&lt;/h1&gt;&lt;p&gt;{*content*}&lt;/p&gt;&apos;);
});


// context: &apos;{CMD}&apos;
// abc.js ==&gt;
;define(function(require, exports, module) {
    module.exports = doT.template(&apos;&lt;h1&gt;{*title*}&lt;/h1&gt;&lt;p&gt;{*content*}&lt;/p&gt;&apos;);
});
</code></pre><h4 id="options-reName"><a href="#options-reName" class="headerlink" title="options.reName"></a>options.reName</h4><p>Type: <code>Function</code> ， Default value: <code>function (name) {return name;}</code></p>
<p>重命名方法，接受一个参数，参数值为源文件名， 此方法的返回值将作为生成的javascript文件名，以及模板函数挂载到的上下文对象属性名。</p>
<p>Example： 下面代码将生成的javascript文件名前面都加上 <code>__</code>， <code>abc.html</code> 将生成 <code>__abc.js</code>。</p>
<pre><code>cptpl: {
    test: {
        options: {
            engine: &apos;dot&apos;,
            reName: function (name) {
                return &apos;__&apos; + name;
            }
        },
        files: {
            &apos;tmp/&apos;: [&apos;test/html/abc.html&apos;]
        }
    }
}

// __abc.js ==&gt;
;window.__abc = doT.template(&apos;&lt;h1&gt;{*title*}&lt;/h1&gt;&lt;p&gt;{*content*}&lt;/p&gt;&apos;);
</code></pre><h4 id="options-customEngines"><a href="#options-customEngines" class="headerlink" title="options.customEngines"></a>options.customEngines</h4><p>Type: <code>Object</code> ， Default value: <code>{}</code></p>
<p>自定义模板引擎预编译包裹方法。如果内置模板引擎无法满足您，可以通过此选项设置一个你需要的模板引擎预编译包裹方法。格式为 <code>{name: function(t){*}</code>， <code>name</code>为模板引擎名， 对应的<code>function(t){}</code>就是包裹方法，接受一个参数t， t为模板文件的文本内容， 您可以拼成用编译函数包裹起来的js代码，并把包裹后的结果作为函数返回值。</p>
<p>Example：</p>
<pre><code>cptpl: {
    test: {
        options: {
            engine: &apos;myEngine&apos;,
            customEngines: {
                myEngine: function (t) {
                    return &apos;myEngine.compile(&apos; + t + &apos;);&apos;
                }
            }
        },
        files: {
            &apos;tmp/&apos;: [&apos;test/html/abc.html&apos;]
        }
    }
}

// abc.js ==&gt;
;window.abc = myEngine.compile(&apos;&lt;h1&gt;{*title*}&lt;/h1&gt;&lt;p&gt;{*content*}&lt;/p&gt;&apos;);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;view-on-Github：https-github-com-hanan198501-grunt-cptpl&quot;&gt;&lt;a href=&quot;#view-on-Github：https-github-com-hanan198501-grunt-cptpl&quot; class=&quot;headerlink&quot; title=&quot;view on Github：https://github.com/hanan198501/grunt-cptpl&quot;&gt;&lt;/a&gt;view on Github：&lt;a href=&quot;https://github.com/hanan198501/grunt-cptpl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/hanan198501/grunt-cptpl&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;grunt-cptpl插件可以将您的文本模板文件编译成javascript文件。在前端开发的时候，模板文本我们一般存放在一个隐藏dom节点，再通过javascript去获取这个节点的内容，将其编译。或者在写javascript的时候，我们手动通过拼接字符串的方式储存模板文本。grunt-cptpl使前端开发也可以像后端一样，把模板文本存放在单独的文件中，使我们的开发工作从繁琐的dom操作和拼串中解放出来，提高我们的开发效率。最主要的，模板文件作为单独文件存放，可以使我们的项目代码逻辑更加清晰，更具可维护性。&lt;/p&gt;
&lt;h5 id=&quot;grunt-cptpl都做了啥？&quot;&gt;&lt;a href=&quot;#grunt-cptpl都做了啥？&quot; class=&quot;headerlink&quot; title=&quot;grunt-cptpl都做了啥？&quot;&gt;&lt;/a&gt;grunt-cptpl都做了啥？&lt;/h5&gt;&lt;p&gt;grunt-cptpl会读取每个模板文件的文本内容，用指定模板引擎的预编译方法将其包裹起来，生成一个新的javascript文件。这个javascript文件文件里面的内容，其实就是模板引擎的预编译方法调用，传入的参数为模板文件的文本内容。这样我们就有了一个编译好的模板函数，要渲染的时候把数据传给它就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://annn.me/categorie/javascript/"/>
    
    
      <category term="grunt" scheme="http://annn.me/tag/grunt/"/>
    
  </entry>
  
  <entry>
    <title>popup组件中mask层的IE6 bug和兼容办法</title>
    <link href="http://annn.me/popup-mask-ie6-bug/"/>
    <id>http://annn.me/popup-mask-ie6-bug/</id>
    <published>2014-03-12T02:02:08.000Z</published>
    <updated>2018-03-16T08:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写一个popup组件时候，通常会加上一个元素作为mask层，用于遮盖住popup元素以外的页面内容。 而IE6下有个著名的bug就是select元素无法被遮盖，通常的做法，在IE6我们会在mask和和popup里面添加一个iframe来解决，一般的，iframe的css会是这样：</p>
<pre><code>#iframe {
    display: block;
    width: 100%;
    height: 100%;
    _filter: Alpha(opacity=0);
    position: absolute;
    top: 0px;
    left: 0px;
    z-index: -1;
}
</code></pre><p>如果popup组件需要一个功能是：点击mask的时候，隐藏popup。 所以，我们会给mask加上click事件来完成这件事。但是，这个办法在IE6下却行不通，不管吧click添加在mask元素，还是添加到mask的iframe里面的document对象，都无法出发click事件。</p>
<p>由于mask只有一个iframe，而iframe里面又没有然后内容，在IE下其实我们点击mask的时候是相当于点击了mask的iframe的window里。解决的办法是在mask里面再添加一个可以被“点击”到的元素，这个元素撑满mask。这样鼠标点击这个元素时候，事件自然会冒泡的mask上，保证了在IE6下mask的click也能正常被触发。</p>
<pre><code>&lt;div id=&quot;mask&quot;&gt;
    &lt;div style=&quot;height: 100%&quot;&gt;&lt;/div&gt;
    &lt;iframe id=&quot;iframe&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在写一个popup组件时候，通常会加上一个元素作为mask层，用于遮盖住popup元素以外的页面内容。 而IE6下有个著名的bug就是select元素无法被遮盖，通常的做法，在IE6我们会在mask和和popup里面添加一个iframe来解决，一般的，iframe的cs
    
    </summary>
    
      <category term="CSS" scheme="http://annn.me/categorie/CSS/"/>
    
    
      <category term="css" scheme="http://annn.me/tag/css/"/>
    
      <category term="iframe" scheme="http://annn.me/tag/iframe/"/>
    
  </entry>
  
</feed>
